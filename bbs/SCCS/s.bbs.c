h33284
s 00005/00006/01602
d D 1.53 88/10/07 08:30:58 dk5sg 55 54
c 
e
s 00114/00073/01494
d D 1.52 88/10/02 10:53:48 dk5sg 54 53
c 
e
s 00002/00001/01565
d D 1.51 88/09/29 22:06:09 dk5sg 53 52
c 
e
s 00006/00003/01560
d D 1.50 88/09/29 08:05:34 dk5sg 52 51
c 
e
s 00093/00100/01470
d D 1.49 88/09/28 23:06:07 dk5sg 51 50
c 
e
s 00008/00008/01562
d D 1.48 88/09/27 22:18:20 dk5sg 50 49
c 
e
s 00020/00021/01550
d D 1.47 88/06/05 10:32:40 dk5sg 49 48
c 
e
s 00561/00355/01010
d D 1.46 88/06/02 22:14:19 dk5sg 48 47
c 
e
s 00002/00002/01363
d D 1.45 88/05/14 17:04:16 dk5sg 47 44
c 
e
s 00010/00009/01389
d R 1.46 88/05/14 10:41:27 dk5sg 46 45
c 
e
s 00037/00004/01361
d R 1.45 88/05/14 10:25:35 dk5sg 45 44
c 
e
s 00023/00047/01342
d D 1.44 88/03/27 10:58:20 dk5sg 44 43
c 
e
s 00009/00004/01380
d D 1.43 88/03/25 23:12:15 dk5sg 43 42
c 
e
s 00002/00002/01382
d D 1.42 88/03/18 22:11:21 dk5sg 42 41
c 
e
s 00001/00001/01383
d D 1.41 88/03/09 19:08:31 dk5sg 41 40
c 
e
s 00002/00000/01382
d D 1.40 88/03/08 00:06:39 dk5sg 40 39
c 
e
s 00005/00005/01377
d D 1.39 88/03/06 20:05:12 dk5sg 39 38
c 
e
s 00041/00027/01341
d D 1.38 88/03/06 11:49:41 dk5sg 38 37
c 
e
s 00001/00001/01367
d D 1.37 88/03/06 07:31:57 dk5sg 37 36
c 
e
s 00003/00000/01365
d D 1.36 88/03/05 19:35:40 dk5sg 36 35
c 
e
s 00002/00001/01363
d D 1.35 88/02/27 15:03:55 dk5sg 35 34
c 
e
s 00009/00003/01355
d D 1.34 87/12/28 09:56:07 dk5sg 34 33
c 
e
s 00003/00003/01355
d D 1.33 87/12/27 21:17:46 dk5sg 33 32
c 
e
s 00006/00004/01352
d D 1.32 87/12/25 08:54:03 dk5sg 32 31
c 
e
s 00003/00005/01353
d D 1.31 87/12/15 22:44:21 dk5sg 31 30
c 
e
s 00016/00003/01342
d D 1.30 87/12/14 21:20:55 dk5sg 30 29
c 
e
s 00002/00003/01343
d D 1.29 87/12/14 20:17:33 dk5sg 29 28
c 
e
s 00003/00001/01343
d D 1.28 87/12/14 07:03:26 dk5sg 28 27
c 
e
s 00045/00000/01299
d D 1.27 87/12/12 19:43:08 dk5sg 27 26
c 
e
s 00069/00027/01230
d D 1.26 87/12/11 22:48:32 dk5sg 26 25
c 
e
s 00044/00024/01213
d D 1.25 87/12/03 06:52:15 dk5sg 25 24
c 
e
s 00006/00004/01231
d D 1.24 87/11/15 09:59:19 dk5sg 24 23
c 
e
s 00015/00004/01220
d D 1.23 87/11/14 22:36:31 dk5sg 23 22
c 
e
s 00021/00018/01203
d D 1.22 87/11/12 21:12:20 dk5sg 22 21
c 
e
s 00302/00129/00919
d D 1.21 87/11/12 20:14:20 dk5sg 21 20
c 
e
s 00006/00000/01042
d D 1.20 87/11/03 21:11:44 dk5sg 20 19
c 
e
s 00002/00007/01040
d D 1.19 87/10/28 20:02:12 dk5sg 19 18
c 
e
s 00001/00001/01046
d D 1.18 87/10/21 21:40:00 dk5sg 18 17
c 
e
s 00007/00001/01040
d D 1.17 87/10/14 22:37:53 dk5sg 17 16
c 
e
s 00008/00010/01033
d D 1.16 87/10/10 18:46:44 dk5sg 16 15
c 
e
s 00031/00023/01012
d D 1.15 87/10/09 23:19:20 dk5sg 15 14
c 
e
s 00003/00004/01032
d D 1.14 87/10/09 08:03:17 dk5sg 14 13
c 
e
s 00005/00005/01031
d D 1.13 87/10/09 07:46:00 dk5sg 13 12
c 
e
s 00025/00008/01011
d D 1.12 87/10/07 22:27:39 dk5sg 12 11
c 
e
s 00133/00027/00886
d D 1.11 87/10/05 22:11:36 dk5sg 11 10
c 
e
s 00070/00020/00843
d D 1.10 87/10/04 10:09:39 dk5sg 10 9
c 
e
s 00001/00002/00862
d D 1.9 87/10/03 07:44:06 dk5sg 9 8
c 
e
s 00001/00002/00863
d D 1.8 87/10/01 20:25:29 dk5sg 8 7
c 
e
s 00007/00010/00858
d D 1.7 87/09/30 13:54:45 dk5sg 7 6
c 
e
s 00019/00028/00849
d D 1.6 87/09/30 12:11:43 dk5sg 6 5
c 
e
s 00009/00003/00868
d D 1.5 87/09/30 09:00:41 dk5sg 5 4
c 
e
s 00801/00064/00070
d D 1.4 87/09/30 08:49:59 dk5sg 4 3
c 
e
s 00002/00002/00132
d D 1.3 87/08/11 08:08:21 dk5sg 3 2
c 
e
s 00032/00012/00102
d D 1.2 87/05/14 22:26:55 dk5sg 2 1
c 
e
s 00114/00000/00000
d D 1.1 87/03/29 20:19:00 dk5sg 1 0
c date and time created 87/03/29 20:19:00 by dk5sg
e
u
U
t
T
I 1
D 21
/* bbs: BBS System emulator */
E 21
I 21
/* Bulletin Board System */
E 21

D 4
static char sccsid[] = "%Z% %M%   %I%   %E% %U%";
E 4
I 4
static char  sccsid[] = "%Z% %M%   %I%   %E% %U%";
E 4

I 4
#include <sys/types.h>

#include <ctype.h>
#include <fcntl.h>
D 9
#include <memory.h>
E 9
D 48
#include <signal.h>
E 48
E 4
#include <stdio.h>
#include <string.h>
I 4
#include <sys/stat.h>
E 4
#include <sys/utsname.h>
I 4
#include <time.h>
E 4

I 48
extern char  *calloc();
E 48
D 4
extern char *getenv();
E 4
I 4
extern char  *getenv();
I 26
extern char  *malloc();
E 26
extern char  *optarg;
extern char  *sys_errlist[];
extern int  errno;
extern int  optind;
extern long  lseek();
extern long  time();
extern unsigned long  sleep();
D 38
extern unsigned short getgid();
extern unsigned short getuid();
E 38
I 38
extern unsigned short  getgid();
extern unsigned short  getuid();
I 48
extern void _exit();
E 48
E 38
E 4
extern void exit();
I 48
extern void free();
E 48

D 4
static char arg[10][1024];
static char logname[1024];
E 4
I 4
D 51
#define halt        errorstop(__LINE__)

E 51
#define DEBUGDIR    "/tmp/bbs"
#define INFOFILE    "/usr/local/lib/station.data"
I 51
#define MYDESC      "[WAMPES BBS Gaertringen, jn48kp]"
E 51
D 21
#define NARGS       10
E 21
I 21
#define NARGS       20
E 21
#define WRKDIR      "/users/bbs"

#define LEN_BID     12
#define LEN_SUBJECT 80
D 50
#define LEN_TO      6
#define LEN_AT      6
#define LEN_FROM    6
E 50
I 50
#define LEN_TO      8
#define LEN_AT      8
#define LEN_FROM    8
E 50

struct index {
  long  size;
  long  date;
D 50
  short  mesg;
E 50
I 50
  int  mesg;
E 50
  char  bid[LEN_BID+1];
  char  type;
  char  subject[LEN_SUBJECT+1];
  char  status;
  char  to[LEN_TO+1];
  char  at[LEN_AT+1];
  char  from[LEN_FROM+1];
};

struct seq {
  int  forw;
  int  list;
};

I 48
struct strlist {
  struct strlist *next;
D 54
  char  line[1];
E 54
I 54
  char  str[1];
E 54
};

struct mail {
  char  from[1024];
  char  to[1024];
  char  subject[1024];
  char  bid[1024];
  char  mid[1024];
  long  date;
  int  type;
  int  status;
  struct strlist *head;
  struct strlist *tail;
};

E 48
static char  *arg[NARGS];
I 51
static char  *mydesc;
static char  *myhostname;
E 51
D 38
static char  *loginname;
E 38
I 38
static char  loginname[80];
E 38
D 15
static char  tempfile[16];
E 15
static int  debug;
static int  findex;
static int  hostmode;
I 54
static int  locked;
E 54
static int  superuser;
I 6
static struct seq seq;
E 6
E 4
static struct utsname utsname;

I 21
static char  *hosts[] = {
I 39
D 51
  "db0aaa", "dj7ka", NULL,
E 39
I 36
D 38

E 36
  "db0cz",
  "db0gv",
I 36
  "db0ie",
E 36
I 35
  "db0sao",
E 35
  "dj7ka",
  "dk4zb",
  "dk5sg",
D 37
  "dl5uy",
E 37
I 36

E 38
I 38
  "db0cz", "dg3saj", NULL,
  "db0gv", "df5ff", NULL,
  "db0ie", "dl5uy", NULL,
  "db0sao", "dk5sg", NULL,
D 39
  "dj7ka", NULL,
E 39
  "dk4zb", NULL,
E 51
I 51
  "db0aaa",
  "db0cz",
  "db0gv",
  "db0ie",
  "db0sao",
E 51
E 38
E 36
  NULL
};

E 21
D 2
/*****************************************************************************/
E 2
I 2
/*---------------------------------------------------------------------------*/
E 2

D 2
void make_lowercase(s)
char *s;
E 2
I 2
D 4
static void make_lowercase(s)
register char *s;
E 4
I 4
static void errorstop(line)
int  line;
E 4
E 2
{
D 4
  for (; *s; s++)
D 3
    if (*s >= 'A' && *s <= 'Z') *s += 32;
E 3
I 3
    if (*s >= 'A' && *s <= 'Z') *s += ('a' - 'A');
E 4
I 4
  printf("Fatal error in line %d: %s\n", line, sys_errlist[errno]);
  puts("Program stopped.");
  exit(1);
E 4
E 3
}

D 2
/*****************************************************************************/
E 2
I 2
/*---------------------------------------------------------------------------*/
E 2

I 51
#define halt() errorstop(__LINE__)

/*---------------------------------------------------------------------------*/

#define uchar(x) ((unsigned char)(x))

/*---------------------------------------------------------------------------*/

E 51
D 2
void b_cmd()
E 2
I 2
D 4
static char *strpos(source, pattern)
char *source, *pattern;
E 4
I 4
static char  *strupc(s)
register char  *s;
E 4
E 2
{
I 2
D 4
  int i, lensource, lenpattern;
E 4
I 4
D 21
  register char  *p;
E 21
I 21
  register char *p;
E 21
E 4

D 4
  lensource = strlen(source);
  lenpattern = strlen(pattern);
  for (; lensource>=lenpattern; source++,lensource--) {
    for (i=0; i<lenpattern; i++)
      if (source[i] != pattern[i]) goto next;
    return source;
next:
    ;
E 4
I 4
D 21
  for (p = s; *p; p++)
    if (*p >= 'a' && *p <= 'z') *p += ('A' - 'a');
E 21
I 21
D 51
  for (p = s; *p = toupper(*p & 0xff); p++) ;
E 51
I 51
  for (p = s; *p = toupper(uchar(*p)); p++) ;
E 51
E 21
  return s;
}

/*---------------------------------------------------------------------------*/

static char  *strlwc(s)
register char  *s;
{
D 21
  register char  *p;
E 21
I 21
  register char *p;
E 21

D 21
  for (p = s; *p; p++)
    if (*p >= 'A' && *p <= 'Z') *p += ('a' - 'A');
E 21
I 21
D 51
  for (p = s; *p = tolower(*p & 0xff); p++) ;
E 51
I 51
  for (p = s; *p = tolower(uchar(*p)); p++) ;
E 51
E 21
  return s;
}

/*---------------------------------------------------------------------------*/

I 54
static int  strcasecmp(s, t)
register char  *s, *t;
{
  for (; tolower(uchar(*s)) == tolower(uchar(*t)); s++, t++)
    if (!*s) return 0;
  return tolower(uchar(*s)) - tolower(uchar(*t));
}

/*---------------------------------------------------------------------------*/

E 54
static char  *strtrim(s)
register char  *s;
{
D 21
  register char  *p;
E 21
I 21
  register char *p;
E 21

  for (p = s; *p; p++) ;
D 21
  while (--p >= s && isspace(*p)) ;
E 21
I 21
D 51
  while (--p >= s && isspace(*p & 0xff)) ;
E 51
I 51
  while (--p >= s && isspace(uchar(*p))) ;
E 51
E 21
  p[1] = '\0';
  return s;
}

/*---------------------------------------------------------------------------*/

I 10
D 54
static char  *strpos(s, p)
D 16
char  *s, *p;
E 16
I 16
register char  *s, *p;
E 54
I 54
static char  *strpos(str, pat)
char  *str, *pat;
E 54
E 16
{
D 16
  int  i, ls, lp;
E 16
I 16
D 54
  register int  i, ls, lp;
E 54
I 54
  register char  *sp, *pp;
E 54
E 16

D 16
  ls = strlen(s);
  lp = strlen(p);
  for (; ls >= lp; s++, ls--) {
E 16
I 16
D 54
  for (ls = strlen(s), lp = strlen(p); ls >= lp; s++, ls--) {
E 16
    for (i = 0; i < lp; i++)
      if (s[i] != p[i]) goto next;
    return s;
next:
    ;
  }
D 16
  return 0;
E 16
I 16
  return NULL;
E 54
I 54
  for (; ; str++)
    for (sp = str, pp = pat; ; ) {
      if (!*pp) return str;
      if (!*sp) return (char *) 0;
      if (*sp++ != *pp++) break;
    }
E 54
E 16
}

/*---------------------------------------------------------------------------*/

E 10
static char  *getstring(s)
D 23
register char  *s;
E 23
I 23
char  *s;
E 23
{
I 23
  register char  *p = s;
  register int  c;

E 23
I 21
  fflush(stdout);
E 21
D 23
  if (gets(s)) return strtrim(s);
  *s = '\0';
  return NULL;
E 23
I 23
  for (; ; ) {
    *p = '\0';
    switch (c = getchar()) {
    case EOF:
      if (p == s) return NULL;
    case '\n':
      return strtrim(s);
    default:
      if (c) *p++ = c;
    }
  }
E 23
}

/*---------------------------------------------------------------------------*/

D 54
static char  *clock_to_str(clock)
long  clock;
E 54
I 54
static char  *timestr(gmt)
long  gmt;
E 54
{
  static char  buf[20];
  struct tm *tm;

D 54
  tm = gmtime(&clock);
D 21
  sprintf(buf, "%2d-%.3s-%02d %2d:%02d UTC", tm->tm_mday, "JanFebMarAprMayJunJulAugSepOctNovDec" + 3 * tm->tm_mon, tm->tm_year % 100, tm->tm_hour, tm->tm_min);
E 21
I 21
  sprintf(buf, "%2d-%.3s/%02d%02d", tm->tm_mday, "JanFebMarAprMayJunJulAugSepOctNovDec" + 3 * tm->tm_mon, tm->tm_hour, tm->tm_min);
E 54
I 54
  tm = gmtime(&gmt);
  sprintf(buf, "%2d-%.3s/%02d%02d",
	       tm->tm_mday,
	       "JanFebMarAprMayJunJulAugSepOctNovDec" + 3 * tm->tm_mon,
	       tm->tm_hour,
	       tm->tm_min);
E 54
E 21
  return buf;
}

/*---------------------------------------------------------------------------*/

I 21
static int  callvalid(call)
register char *call;
{
  register int  d, l;

  l = strlen(call);
  if (l < 4 || l > 6) return 0;
D 51
  if (!isalpha(call[l-1] & 0xff)) return 0;
E 51
I 51
  if (!isalpha(uchar(call[l-1]))) return 0;
E 51
  d = 0;
  for (; *call; call++) {
D 51
    if (!isalnum(*call & 0xff)) return 0;
    if (isdigit(*call & 0xff)) d++;
E 51
I 51
    if (!isalnum(uchar(*call))) return 0;
    if (isdigit(uchar(*call))) d++;
E 51
  }
  if (d < 1 || d > 2) return 0;
  return 1;
}

/*---------------------------------------------------------------------------*/

I 38
D 51
static void fix_call(raw, fixed)
char  *raw, *fixed;
{
D 39
  register char  *cp, **p;
E 39
I 39
  register char  *f, **p;
E 39

D 39
  for (cp = fixed; *cp++ = tolower(*raw++ & 0xff); ) ;
E 39
I 39
  strlwc(strcpy(fixed, raw));
E 39
  for (p = hosts; *p; p++)
D 39
    for (cp = *p; *p; p++)
E 39
I 39
    for (f = *p; *p; p++)
E 39
      if (!strcmp(*p, fixed)) {
D 39
	strcpy(fixed, cp);
E 39
I 39
	strcpy(fixed, f);
E 39
	return;
      }
}

/*---------------------------------------------------------------------------*/

E 51
E 38
D 54
static int  calleq(c1, c2)
D 38
register char  *c1, *c2;
E 38
I 38
char  *c1, *c2;
E 38
{
D 38
  for (; ; ) {
    if (toupper(*c1 & 0xff) != toupper(*c2 & 0xff)) return 0;
    if (!*c1) return 1;
    c1++;
    c2++;
  }
E 38
I 38
  char  buf1[80], buf2[80];
E 54
I 54
#define calleq(c1, c2) (!strcasecmp((c1), (c2)))
E 54

D 51
  fix_call(c1, buf1);
  fix_call(c2, buf2);
E 51
I 51
D 54
  strlwc(strcpy(buf1, c1));
  strlwc(strcpy(buf2, c2));
E 51
  return !strcmp(buf1, buf2);
E 38
}

E 54
/*---------------------------------------------------------------------------*/

E 21
static char  *dirname(mesg)
int  mesg;
{
  static char  buf[4];

  sprintf(buf, "%03d", mesg / 100);
  return buf;
}

/*---------------------------------------------------------------------------*/

static char  *filename(mesg)
int  mesg;
{
  static char  buf[8];

  sprintf(buf, "%03d/%02d", mesg / 100, mesg % 100);
  return buf;
}

/*---------------------------------------------------------------------------*/

D 6
static void get_seq(seq)
struct seq *seq;
E 6
I 6
static void get_seq()
E 6
{

  FILE * fp;
  char  fname[80];

D 6
  memset((char *) seq, 0, sizeof(struct seq ));
E 6
  sprintf(fname, "seq/seq.%s", loginname);
  if (fp = fopen(fname, "r")) {
D 6
    fscanf(fp, "%d %d", &seq->forw, &seq->list);
E 6
I 6
    fscanf(fp, "%d %d", &seq.forw, &seq.list);
E 6
    fclose(fp);
E 4
  }
I 4
}

/*---------------------------------------------------------------------------*/

D 6
static void put_seq(seq)
struct seq *seq;
E 6
I 6
static void put_seq()
E 6
{

  FILE * fp;
  char  fname[80];

  sprintf(fname, "seq/seq.%s", loginname);
D 6
  if (!(fp = fopen(fname, "w")) || fprintf(fp, "%d %d\n", seq->forw, seq->list) < 0) halt;
E 6
I 6
D 51
  if (!(fp = fopen(fname, "w")) || fprintf(fp, "%d %d\n", seq.forw, seq.list) < 0) halt;
E 51
I 51
  if (!(fp = fopen(fname, "w")) || fprintf(fp, "%d %d\n", seq.forw, seq.list) < 0) halt();
E 51
E 6
  fclose(fp);
}

/*---------------------------------------------------------------------------*/

D 21
static void char *generate_bid()
{

  FILE * fp;
  int  n;
  register char  *f, *t;
  static char  bid[LEN_BID+1];

  n = 0;
  if (fp = fopen("seq/seq.bid", "r")) {
    fscanf(fp, "%d", &n);
    fclose(fp);
  }
  n++;
  if (!(fp = fopen("seq/seq.bid", "w")) || fprintf(fp, "%d\n", n) < 0) halt;
  fclose(fp);
  sprintf(bid, "%012d", n);
  for (f = utsname.nodename, t = bid; *f; *t++ = *f++) ;
  return strupc(bid);
}

/*---------------------------------------------------------------------------*/

E 21
I 12
D 15
static FILE *create_tempfile()
E 15
I 15
D 48
static FILE *create_tempfile(fname)
char *fname;
E 15
{

D 15
  FILE * fp;
  static int  tempcount;
E 15
I 15
  FILE *fp;
  static int tempcount;
E 15

D 15
  sprintf(tempfile, "tmp/tmp.%05d.%04d", getpid(), tempcount++);
  if (!(fp = fopen(tempfile, "w"))) halt;
E 15
I 15
  sprintf(fname, "tmp/tmp.%05d.%04d", getpid(), tempcount++);
  if (!(fp = fopen(fname, "w"))) halt;
E 15
  return fp;
}

/*---------------------------------------------------------------------------*/

E 12
I 10
static int  host_in_header(fname, host)
char  *fname;
char  *host;
{

D 21
  FILE  *fp;
  char  *p;
E 21
I 21
  FILE  * fp;
E 21
  char  buf[1024];
D 21
  char  uhost[80];
  int  found;
  int  lenhost;
E 21
I 21
  register char  *p, *q;
E 21

D 21
  strupc(strcpy(uhost, host));
  lenhost = strlen(host);
E 21
  if (!(fp = fopen(fname, "r"))) halt;
D 21
  found = 0;
  while (fgets(buf, sizeof(buf), fp))
    if (buf[0] == 'R' && buf[1] == ':' && buf[2] >= '0' && buf[2] <= '9' && (p = strpos(buf, uhost)) && isspace(p[lenhost])) {
      found = 1;
      break;
E 21
I 21
D 25
  while (fgets(buf, sizeof(buf), fp) && buf[0] == 'R' && buf[1] == ':' && isdigit(buf[2] & 0xff) && (p = strpos(buf, " @:"))) {
    p += 3;
    for (q = p; isalnum(*q & 0xff); q++) ;
    *q = '\0';
    if (calleq(p, host)) {
      fclose(fp);
      return 1;
E 25
I 25
  while (fgets(buf, sizeof(buf), fp))
D 32
    if (buf[0] == 'R' && buf[1] == ':' && isdigit(buf[2] & 0xff) && (p = strpos(buf, " @:"))) {
      p += 3;
E 32
I 32
D 47
    if (buf[0] == 'R' && buf[1] == ':' && isdigit(buf[2] & 0xff) && (p = strchr(buf, '@'))) {
E 47
I 47
    if (buf[0] == 'R' && buf[1] == ':' && (p = strchr(buf, '@'))) {
E 47
      p++;
I 40
      while (isspace(*p & 0xff)) p++;
E 40
      if (*p == ':') p++;
E 32
      for (q = p; isalnum(*q & 0xff); q++) ;
      *q = '\0';
      if (calleq(p, host)) {
	fclose(fp);
	return 1;
      }
E 25
E 21
    }
I 21
D 25
  }
E 25
E 21
  fclose(fp);
D 21
  return found;
E 21
I 21
  return 0;
E 21
}

/*---------------------------------------------------------------------------*/

E 48
I 26
static int  can_forward(host)
char  *host;
{

D 54
  static struct s {
    struct s *next;
    char  name[1];
  } *s;

E 54
  FILE * fp;
  char  *cp;
  char  buf[1024];
  char  s1[1024];
  char  s2[1024];
D 54
  register struct s *p;
E 54
I 54
  register struct strlist *p;
E 54
  static int  initialized;
I 54
  static struct strlist *hostlist;
E 54

  if (calleq(host, loginname)) return 1;
  if (!initialized) {
    initialized = 1;
    if (!(fp = fopen("/usr/lib/mail/paths", "r"))) return 0;
    while (fgets(buf, sizeof(buf), fp))
D 54
      if (fscanf(fp, "%s %s", s1, s2) == 2) {
E 54
I 54
      if (sscanf(buf, "%s%s", s1, s2) == 2) {
E 54
	if (cp = strchr(s2, '!')) *cp = '\0';
	if (!strcmp(s2, loginname)) {
D 54
	  p = (struct s *) malloc(sizeof(struct s ) + strlen(s1));
	  strcpy(p->name, s1);
	  p->next = s;
	  s = p;
E 54
I 54
	  p = (struct strlist *) malloc(sizeof(struct strlist ) + strlen(s1));
	  strcpy(p->str, s1);
	  p->next = hostlist;
	  hostlist = p;
E 54
	}
      }
    fclose(fp);
  }
D 54
  for (p = s; p; p = p->next)
    if (calleq(p->name, host)) return 1;
E 54
I 54
  for (p = hostlist; p; p = p->next)
    if (calleq(p->str, host)) return 1;
E 54
  return 0;
}

/*---------------------------------------------------------------------------*/

E 26
E 10
static int  check_abort()
{

  char  buf[1024];
  int  rmask;
  static struct timeval timeout;

  rmask = 1;
D 54
  if (select(1, &rmask, 0, 0, &timeout) == 1) {
E 54
I 54
  if (select(1, &rmask, (int *) 0, (int *) 0, &timeout) == 1) {
E 54
    getstring(buf);
    if (*buf == 'A' || *buf == 'a') {
      puts("*** Aborted by User ***");
      return 1;
    }
  }
E 4
  return 0;
}

/*---------------------------------------------------------------------------*/

I 4
static void lock()
{
I 54
  int  fd, try;
E 54

D 54
  int  fd;
  unsigned long  try;

  for (try = 1l; try <= 10l; try++) {
    if ((fd = open("lock", O_WRONLY | O_CREAT | O_EXCL, 0644)) != -1) {
D 51
      if (close(fd)) halt;
E 51
I 51
      if (close(fd)) halt();
E 51
      return;
E 54
I 54
  if (!locked) {
    for (try = 1; ; try++) {
      if (try > 10) halt();
      if ((fd = open("lock", O_WRONLY | O_CREAT | O_EXCL, 0644)) >= 0) break;
      sleep((unsigned long) try);
E 54
    }
D 54
    sleep(try);
E 54
I 54
    if (close(fd)) halt();
E 54
  }
D 51
  halt;
E 51
I 51
D 54
  halt();
E 54
I 54
  locked++;
E 54
E 51
}

/*---------------------------------------------------------------------------*/

static void unlock()
{
D 51
  if (unlink("lock")) halt;
E 51
I 51
D 54
  if (unlink("lock")) halt();
E 54
I 54
  locked--;
  if (locked <= 0)
    if (unlink("lock")) halt();
E 54
E 51
}

/*---------------------------------------------------------------------------*/

static int  lastmesg()
{
D 21
  struct index index;
E 21

D 21
  if (lseek(findex, (long) (-sizeof(struct index )), 2) < 0) return 0;
  if (read(findex, (char *) & index, sizeof(struct index )) != sizeof(struct index )) halt;
  return index.mesg;
E 21
I 21
  FILE * fp;
  int  n;

  n = 0;
  if (fp = fopen("seq/seq.msg", "r")) {
    fscanf(fp, "%d", &n);
    fclose(fp);
  }
  return n;
E 21
}

/*---------------------------------------------------------------------------*/

I 21
static int  nextmesg()
{

  FILE * fp;
  int  n;

  n = lastmesg() + 1;
D 51
  if (!(fp = fopen("seq/seq.msg", "w")) || fprintf(fp, "%d\n", n) < 0) halt;
E 51
I 51
  if (!(fp = fopen("seq/seq.msg", "w")) || fprintf(fp, "%d\n", n) < 0) halt();
E 51
  fclose(fp);
  return n;
}

/*---------------------------------------------------------------------------*/

E 21
static int  numbmesg()
{
D 5
  long  size;
E 5

D 5
  if ((size = lseek(findex, 0l, 2)) < 0) halt;
  return size / sizeof(struct index );
E 5
I 5
  int  n;
  struct index index;

  n = 0;
D 51
  if (lseek(findex, 0l, 0)) halt;
E 51
I 51
  if (lseek(findex, 0l, 0)) halt();
E 51
  while (read(findex, (char *) & index, sizeof(struct index )) == sizeof(struct index ))
    if (index.mesg) n++;
  return n;
E 5
}

/*---------------------------------------------------------------------------*/

I 21
D 48
static char  *generate_bid(mesg)
int  mesg;
E 48
I 48
static int  read_allowed(index)
struct index *index;
E 48
{
I 48
  return superuser || index->type != 'P' || calleq(index->from, loginname) || calleq(index->to, loginname);
}
E 48

D 48
  register char  *f, *t;
  static char  bid[LEN_BID+1];
E 48
I 48
/*---------------------------------------------------------------------------*/
E 48

D 48
  sprintf(bid, "%012d", mesg);
  for (f = utsname.nodename, t = bid; *f; *t++ = *f++) ;
  return strupc(bid);
E 48
I 48
static void unknown_command()
{
  printf("Unknown command '%s'.  Type ? for help.\n", arg[0]);
E 48
}

/*---------------------------------------------------------------------------*/

E 21
D 15
static void store(bid, type, subject, status, to, at, from)
E 15
I 15
D 16
static void store(fname, bid, type, subject, status, to, at, from)
E 16
I 16
D 48
static void store_in_bbs(fname, bid, type, subject, status, to, at, from)
E 16
char *fname;
E 48
I 48
static char  *get_user_from_path(path)
char  *path;
{
  register char  *cp;

  return (cp = strrchr(path, '!')) ? cp + 1 : path;
}

/*---------------------------------------------------------------------------*/

static char  *get_host_from_path(path)
char  *path;
{

  register char  *cp;
  static char  tmp[1024];

  strcpy(tmp, path);
  if (!(cp = strrchr(tmp, '!'))) return "";
  *cp = '\0';
  return (cp = strrchr(tmp, '!')) ? cp + 1 : tmp;
}

/*---------------------------------------------------------------------------*/

D 49
static int  bid_uniq(bid)
E 48
E 15
char  *bid;
E 49
I 49
static int  msg_uniq(bid, mid)
char  *bid, *mid;
E 49
D 48
int  type;
char  *subject;
int  status;
char  *to;
char  *at;
char  *from;
E 48
{
I 48
  struct index index;
E 48

I 48
D 51
  if (lseek(findex, 0l, 0)) halt;
E 51
I 51
  if (lseek(findex, 0l, 0)) halt();
E 51
D 49
  while (read(findex, (char *) & index, sizeof(struct index )) == sizeof(struct index ))
E 49
I 49
  while (read(findex, (char *) &index, sizeof(struct index )) == sizeof(struct index ))
E 49
    if (!strcmp(bid, index.bid)) return 0;
  return 1;
}

/*---------------------------------------------------------------------------*/

static void send_to_bbs(mail)
struct mail *mail;
{

  FILE * fp;
E 48
  struct index index;
D 48
  struct stat statbuf;
E 48
I 48
  struct strlist *p;
E 48

  lock();
D 21
  index.mesg = lastmesg() + 1;
E 21
I 21
D 48
  index.mesg = nextmesg();
E 21
D 15
  if (stat(tempfile, &statbuf)) halt;
E 15
I 15
  if (stat(fname, &statbuf)) halt;
E 15
  index.size = statbuf.st_size;
  index.date = time(0);
D 21
  strncpy(index.bid, *bid ? bid : generate_bid(), LEN_BID);
  index.bid[LEN_BID] = '\0';
  strupc(index.bid);
E 21
I 21
  if (status != '$')
    *index.bid = '\0';
  else {
    strncpy(index.bid, *bid ? bid : generate_bid(index.mesg), LEN_BID);
    index.bid[LEN_BID] = '\0';
    strupc(index.bid);
E 48
I 48
D 49
  if (bid_uniq(mail->bid)) {
E 49
I 49
  if (msg_uniq(mail->bid, mail->mid)) {
E 49
    index.mesg = nextmesg();
    index.size = 0;
    if (!(fp = fopen(filename(index.mesg), "w"))) {
      mkdir(dirname(index.mesg), 0755);
D 51
      if (!(fp = fopen(filename(index.mesg), "w"))) halt;
E 51
I 51
      if (!(fp = fopen(filename(index.mesg), "w"))) halt();
E 51
    }
    for (p = mail->head; p; p = p->next) {
D 51
      if (fputs(p->line, fp) == EOF) halt;
      if (putc('\n', fp) == EOF) halt;
E 51
I 51
D 54
      if (fputs(p->line, fp) == EOF) halt();
E 54
I 54
      if (fputs(p->str, fp) == EOF) halt();
E 54
      if (putc('\n', fp) == EOF) halt();
E 51
D 54
      index.size += (strlen(p->line) + 1);
E 54
I 54
      index.size += (strlen(p->str) + 1);
E 54
    }
    fclose(fp);
    index.date = mail->date;
    strcpy(index.bid, mail->bid);
    index.type = mail->type;
    strncpy(index.subject, mail->subject, LEN_SUBJECT);
    index.subject[LEN_SUBJECT] = '\0';
    index.status = mail->status;
    strncpy(index.to, get_user_from_path(mail->to), LEN_TO);
    index.to[LEN_TO] = '\0';
    strupc(index.to);
    strncpy(index.at, get_host_from_path(mail->to), LEN_AT);
    index.at[LEN_AT] = '\0';
    strupc(index.at);
    strncpy(index.from, get_user_from_path(mail->from), LEN_FROM);
    index.from[LEN_FROM] = '\0';
    strupc(index.from);
D 51
    if (lseek(findex, 0l, 2) < 0) halt;
    if (write(findex, (char *) & index, sizeof(struct index )) != sizeof(struct index )) halt;
E 51
I 51
    if (lseek(findex, 0l, 2) < 0) halt();
    if (write(findex, (char *) & index, sizeof(struct index )) != sizeof(struct index )) halt();
E 51
E 48
  }
E 21
D 48
  index.type = type;
  strncpy(index.subject, subject, LEN_SUBJECT);
  index.subject[LEN_SUBJECT] = '\0';
  index.status = status;
  strncpy(index.to, to, LEN_TO);
  index.to[LEN_TO] = '\0';
  strupc(index.to);
  strncpy(index.at, at, LEN_AT);
  index.at[LEN_AT] = '\0';
  strupc(index.at);
  strncpy(index.from, from, LEN_FROM);
  index.from[LEN_FROM] = '\0';
  strupc(index.from);
D 15
  if (link(tempfile, filename(index.mesg))) {
E 15
I 15
  if (link(fname, filename(index.mesg))) {
E 15
    mkdir(dirname(index.mesg), 0755);
D 15
    if (link(tempfile, filename(index.mesg))) halt;
E 15
I 15
    if (link(fname, filename(index.mesg))) halt;
E 15
  }
  if (lseek(findex, 0l, 2) < 0) halt;
  if (write(findex, (char *) & index, sizeof(struct index )) != sizeof(struct index )) halt;
E 48
  unlock();
}

/*---------------------------------------------------------------------------*/

I 21
D 48
static int  read_allowed(index)
struct index *index;
E 48
I 48
static void send_to_mail(mail)
struct mail *mail;
E 48
{
D 48
  return superuser || index->type != 'P' || calleq(index->from, loginname) || calleq(index->to, loginname);
E 48
I 48

  FILE * fp;
  char  command[1024];
  int  i;
  struct strlist *p;

  switch (fork()) {
  case -1:
D 51
    halt;
E 51
I 51
    halt();
E 51
  case 0:
    setuid(0);
    setgid(1);
    for (i = 0; i < _NFILE; i++) close(i);
    setpgrp();
    fopen("/dev/null", "r+");
    fopen("/dev/null", "r+");
    fopen("/dev/null", "r+");
    switch (fork()) {
    case -1:
      _exit(1);
    case 0:
      sprintf(command, "/usr/lib/sendmail -oi -oem -f %s %s", mail->from, mail->to);
      if (!(fp = popen(command, "w"))) _exit(1);
      fprintf(fp, "From: %s\n", mail->from);
      fprintf(fp, "To: %s\n", mail->to);
      if (*mail->subject) fprintf(fp, "Subject: %s\n", mail->subject);
      fprintf(fp, "Bulletin-ID: <%s>\n", mail->bid);
      fprintf(fp, "Message-ID: <%s>\n", mail->mid);
      putc('\n', fp);
      for (p = mail->head; p; p = p->next) {
D 54
	fputs(p->line, fp);
E 54
I 54
	fputs(p->str, fp);
E 54
	putc('\n', fp);
      }
      pclose(fp);
      _exit(0);
    default:
      _exit(0);
    }
  default:
    wait((int *) 0);
  }
E 48
}

/*---------------------------------------------------------------------------*/

E 21
I 11
D 48
static void unknown_command()
E 48
I 48
static void send_to_news(mail)
struct mail *mail;
E 48
{
D 48
  printf("Unknown command '%s'.  Type ? for help.\n", arg[0]);
E 48
I 48

  FILE * fp;
  char  *fromhost;
  int  i;
  long  mst;
  struct strlist *p;
  struct tm *tm;

  switch (fork()) {
  case -1:
D 51
    halt;
E 51
I 51
    halt();
E 51
  case 0:
    setuid(0);
    setgid(1);
    for (i = 0; i < _NFILE; i++) close(i);
    setpgrp();
    fopen("/dev/null", "r+");
    fopen("/dev/null", "r+");
    fopen("/dev/null", "r+");
    switch (fork()) {
    case -1:
      _exit(1);
    case 0:
      if (!(fp = popen("/usr/bin/rnews", "w"))) _exit(1);
D 51
      fprintf(fp, "Relay-Version: DK5SG BBS v%I% - %E%; site %s\n", utsname.nodename);
E 51
I 51
      fprintf(fp, "Relay-Version: DK5SG BBS v%I% - %E%; site %s\n", myhostname);
E 51
      fromhost = get_host_from_path(mail->from);
D 51
      if (!*fromhost) fromhost = utsname.nodename;
E 51
I 51
D 54
      if (!*fromhost) fromhost = myhostname;
E 54
E 51
D 50
      fprintf(fp, "From: %s@%s%s\n", get_user_from_path(mail->from), fromhost, strchr(fromhost, '.') ? "" : ".ampr");
E 50
I 50
      fprintf(fp, "From: %s@%s%s\n", get_user_from_path(mail->from), fromhost, strchr(fromhost, '.') ? "" : ".ampr.org");
E 50
      mst = mail->date - 7 * 60 * 60;
      tm = gmtime(&mst);
      fprintf(fp, "Date: %.3s, %d %.3s %02d %02d:%02d:%02d MST\n",
	      "SunMonTueWedThuFriSat" + 3 * tm->tm_wday,
	      tm->tm_mday,
	      "JanFebMarAprMayJunJulAugSepOctNovDec" + 3 * tm->tm_mon,
	      tm->tm_year % 100,
	      tm->tm_hour,
	      tm->tm_min,
	      tm->tm_sec);
      if (*mail->subject) fprintf(fp, "Subject: %s\n", mail->subject);
      fprintf(fp, "Bulletin-ID: <%s>\n", mail->bid);
      fprintf(fp, "Message-ID: <%s>\n", mail->mid);
      fprintf(fp, "Path: %s\n", mail->from);
      if (debug)
D 51
	fprintf(fp, "Newsgroups: %s.test\n", utsname.nodename);
E 51
I 51
	fprintf(fp, "Newsgroups: %s.test\n", myhostname);
E 51
      else
	fprintf(fp, "Newsgroups: dnet.ham\n");
D 51
      fprintf(fp, "Posting-Version: DK5SG BBS v%I% - %E%; site %s\n", utsname.nodename);
E 51
I 51
      fprintf(fp, "Posting-Version: DK5SG BBS v%I% - %E%; site %s\n", myhostname);
E 51
      putc('\n', fp);
      for (p = mail->head; p; p = p->next) {
D 54
	fputs(p->line, fp);
E 54
I 54
	fputs(p->str, fp);
E 54
	putc('\n', fp);
      }
      pclose(fp);
      _exit(0);
    default:
      _exit(0);
    }
  default:
    wait((int *) 0);
  }
E 48
}

/*---------------------------------------------------------------------------*/

I 54
static void fix_address(addr)
char  *addr;
{

  char  tmp[1024];
  register char  *p1, *p2;

  for (p1 = addr; *p1; p1++)
    switch (*p1) {
    case '^':
      *p1 = '!';
      break;
    case ',':
      *p1 = ':';
      break;
    case '%':
      *p1 = '@';
      break;
    }

  while ((p1 = strchr(addr, '@')) && (p2 = strchr(p1, ':'))) {
    *p1 = *p2 = '\0';
    sprintf(tmp, "%s%s!%s", addr, p1 + 1, p2 + 1);
    strcpy(addr, tmp);
  }

  while (p2 = strrchr(addr, '@')) {
    *p2 = '\0';
    p1 = p2;
    while (p1 > addr && *p1 != '!') p1--;
    if (p1 == addr)
      sprintf(tmp, "%s!%s", p2 + 1, addr);
    else {
      *p1 = '\0';
      sprintf(tmp, "%s!%s!%s", addr, p2 + 1, p1 + 1);
    }
    strcpy(addr, tmp);
  }

  if (!strchr(addr, '!')) {
    sprintf(tmp, "%s!%s", myhostname, addr);
    strcpy(addr, tmp);
  }

  strlwc(addr);
}

/*---------------------------------------------------------------------------*/

E 54
I 48
static void route_mail(mail)
struct mail *mail;
{

#define BidSeqFile "seq/seq.bid"
#define MidSuffix  "@bbs.net"

  FILE * fp;
  int  n;
  register char  *cp;
  register char  *s;
  struct strlist *p;

  /* Set date */

  mail->date = time(0);

  /* Fix addresses */

D 54
  strlwc(mail->from);
  strlwc(mail->to);
E 54
I 54
  fix_address(mail->from);
  fix_address(mail->to);
E 54

  /* Set type & status */

  if (hostmode) {
    if (*mail->bid) {
      mail->type = 'B';
      mail->status = '$';
    } else {
      mail->type = callvalid(get_user_from_path(mail->to)) ? 'P' : 'B';
      mail->status = 'N';
    }
  } else {
    mail->type = callvalid(get_user_from_path(mail->to)) ? 'P' : 'B';
D 54
    if (mail->type == 'P')
      mail->status = 'N';
    else if (callvalid(get_host_from_path(mail->to)))
      mail->status = 'N';
    else if (*get_host_from_path(mail->to))
      mail->status = '$';
    else if (*mail->bid)
      mail->status = '$';
    else
      mail->status = 'N';
E 54
I 54
    mail->status =
      (mail->type=='P' || callvalid(get_host_from_path(mail->to))) ? 'N' : '$';
E 54
  }

  /* Set bid */

  if (!*mail->bid && (cp = strchr(mail->mid, '@')) && !strcmp(cp, MidSuffix)) {
    strcpy(mail->bid, mail->mid);
    mail->bid[strlen(mail->bid)-strlen(MidSuffix)] = '\0';
  }
  if (!*mail->bid) {
    n = 0;
I 49
    lock();
E 49
    if (fp = fopen(BidSeqFile, "r")) {
      fscanf(fp, "%d", &n);
      fclose(fp);
    }
    n++;
D 51
    if (!(fp = fopen(BidSeqFile, "w")) || fprintf(fp, "%d\n", n) < 0) halt;
E 51
I 51
    if (!(fp = fopen(BidSeqFile, "w")) || fprintf(fp, "%d\n", n) < 0) halt();
E 51
    fclose(fp);
I 49
    unlock();
E 49
    sprintf(mail->bid, "%012d", n);
D 51
    strncpy(mail->bid, utsname.nodename, strlen(utsname.nodename));
E 51
I 51
    strncpy(mail->bid, myhostname, strlen(myhostname));
E 51
  }
  mail->bid[LEN_BID] = '\0';
  strupc(mail->bid);

  /* Set mid */

  if (!*mail->mid) {
    strcpy(mail->mid, mail->bid);
    strcat(mail->mid, MidSuffix);
  }

  /* Remove all message delimiters */

  for (p = mail->head; p; p = p->next) {
D 54
    s = p->line;
E 54
I 54
    s = p->str;
E 54
    if (!strcmp(s, ".")) *s = '\0';
D 49
    while (cp = strchr(s, '\004')) while (cp[0] = cp[1]) cp++;
    while (cp = strchr(s, '\032')) while (cp[0] = cp[1]) cp++;
    while (cp = strpos(s, "***END")) while (cp[0] = cp[1]) cp++;
    while (cp = strpos(s, "***end")) while (cp[0] = cp[1]) cp++;
    while (cp = strpos(s, "/EX")) while (cp[0] = cp[1]) cp++;
    while (cp = strpos(s, "/ex")) while (cp[0] = cp[1]) cp++;
E 49
I 49
    while (cp = strchr(s, '\004'))   while (cp[0] = cp[1]) cp++;
    while (cp = strchr(s, '\032'))   while (cp[0] = cp[1]) cp++;
    while (cp = strpos(s, "/EX"))    while (cp[0] = cp[3]) cp++;
    while (cp = strpos(s, "/ex"))    while (cp[0] = cp[3]) cp++;
    while (cp = strpos(s, "***END")) while (cp[0] = cp[6]) cp++;
    while (cp = strpos(s, "***end")) while (cp[0] = cp[6]) cp++;
E 49
  }

  /* Call delivery agents */

  if (mail->type == 'P') send_to_mail(mail);
  if (mail->type == 'B') send_to_bbs(mail);
  if (mail->type == 'B' && mail->status == '$') send_to_news(mail);

  /* Free mail */

  while (p = mail->head) {
    mail->head = p->next;
    free((char *) p);
  }
  free((char *) mail);

}

/*---------------------------------------------------------------------------*/

static void append_line(mail, line)
struct mail *mail;
char  *line;
{
  register struct strlist *p;

  p = (struct strlist *) malloc(sizeof(struct strlist ) + strlen(line));
I 49
  p->next = NULL;
E 49
D 54
  strcpy(p->line, line);
E 54
I 54
  strcpy(p->str, line);
E 54
  if (!mail->head)
    mail->head = p;
  else
    mail->tail->next = p;
  mail->tail = p;
}

/*---------------------------------------------------------------------------*/

static void  get_header_value(name, line, value)
char  *name, *line, *value;
{
  char  *p1, *p2;

  while (*name)
D 51
    if (tolower(*name++ & 0xff) != tolower(*line++ & 0xff)) return;
E 51
I 51
    if (tolower(uchar(*name++)) != tolower(uchar(*line++))) return;
E 51
D 54
  while (*line == ' ' || *line == '\t') line++;
E 54
I 54
  while (isspace(uchar(*line))) line++;
E 54
  while ((p1 = strchr(line, '<')) && (p2 = strrchr(p1, '>'))) {
    *p2 = '\0';
    line = p1 + 1;
  }
  strcpy(value, line);
}

/*---------------------------------------------------------------------------*/

static char  *get_host_from_header(line)
char  *line;
{

  register char  *p, *q;
  static char  buf[1024];

  if (*line == 'R' && line[1] == ':' && (p = strchr(strcpy(buf, line), '@'))) {
    p++;
D 51
    while (isspace(*p & 0xff)) p++;
E 51
I 51
D 54
    while (isspace(uchar(*p))) p++;
E 51
    if (*p == ':') p++;
E 54
I 54
    while (*p == ':' || isspace(uchar(*p))) p++;
E 54
D 51
    for (q = p; isalnum(*q & 0xff); q++) ;
E 51
I 51
    for (q = p; isalnum(uchar(*q)); q++) ;
E 51
    *q = '\0';
    return p;
  }
  return NULL;
}

/*---------------------------------------------------------------------------*/

static int  host_in_header(fname, host)
char  *fname;
char  *host;
{

  FILE  * fp;
  char  buf[1024];
  register char  *p;

D 51
  if (!(fp = fopen(fname, "r"))) halt;
E 51
I 51
  if (!(fp = fopen(fname, "r"))) halt();
E 51
  while (fgets(buf, sizeof(buf), fp))
    if ((p = get_host_from_header(buf)) && calleq(p, host)) {
      fclose(fp);
      return 1;
    }
  fclose(fp);
  return 0;
}

/*---------------------------------------------------------------------------*/

static void s_cmd()
{

  char  *p;
  char  at[1024];
  char  line[1024];
  char  path[1024];
  int  check_header = 1;
  int  i;
  struct mail *mail;

  if (strlen(arg[0]) > 2) {
    unknown_command();
    return;
  }
  mail = (struct mail *) calloc(1, sizeof(struct mail ));
  *at = *path = '\0';
  if (*arg[1]) strcpy(mail->to, arg[1]);
  for (i = 2; i < NARGS; i++)
    switch (*arg[i]) {
    case '@':
      strcpy(at, arg[i][1] ? arg[i] + 1 : arg[++i]);
      break;
    case '<':
      strcpy(mail->from, arg[i][1] ? arg[i] + 1 : arg[++i]);
      break;
    case '$':
      strcpy(mail->bid, arg[i][1] ? arg[i] + 1 : arg[++i]);
      break;
    }
  if (p = strchr(mail->to, '@')) {
    *p++ = '\0';
    strcpy(at, p);
  }
  if (p = strchr(at, '<')) {
    *p++ = '\0';
    strcpy(mail->from, p);
  }
  if (p = strchr(mail->from, '$')) {
    *p++ = '\0';
    strcpy(mail->bid, p);
  }
  if (*mail->bid) {
    mail->bid[LEN_BID] = '\0';
    strupc(mail->bid);
D 49
    if (!bid_uniq(mail->bid)) {
E 49
I 49
    if (!msg_uniq(mail->bid, mail->mid)) {
E 49
      puts("NO, Bulletin-ID already exists");
      free((char *) mail);
      return;
    }
  }
  puts(hostmode ? "OK, go ahead" : "Enter subject:");
  getstring(mail->subject);
  if (!hostmode) puts("Enter message: (terminate with ^Z or /EX or ***END)");
  for (; ; ) {
    if (!getstring(line)) break;
    if (*line == '\032') break;
D 49
    if (!strcmp(line, "/EX")) break;
    if (!strcmp(line, "/ex")) break;
    if (!strcmp(line, "***END")) break;
    if (!strcmp(line, "***end")) break;
E 49
I 49
    if (!strncmp(line, "/EX", 3)) break;
    if (!strncmp(line, "/ex", 3)) break;
    if (!strncmp(line, "***END", 6)) break;
    if (!strncmp(line, "***end", 6)) break;
E 49
    append_line(mail, line);
    if (check_header) {
      if (p = get_host_from_header(line)) {
D 49
	if (!*path)
	  strcpy(path, p);
	else {
	  strcat(path, "!");
	  strcat(path, p);
	}
E 49
I 49
	if (*path) strcat(path, "!");
	strcat(path, p);
E 49
      } else if (*path)
	check_header = 0;
    }
    if (strchr(line, '\032')) break;
  }
  if (!*mail->to) strcpy(mail->to, "ALLE");
  if (*at) {
    strcpy(line, mail->to);
    sprintf(mail->to, "%s!%s", at, line);
  }
  if (!*mail->from || !hostmode && !superuser) strcpy(mail->from, loginname);
  if (*path) {
    strcpy(line, mail->from);
    sprintf(mail->from, "%s!%s", path, line);
  }
  if (!hostmode) /*!!!!!!!!!! Print Ack !!!!!!!!!!!!!!!*/ ;
  route_mail(mail);
}

/*---------------------------------------------------------------------------*/

static void rmail()
{

  char  line[1024];
  int  state = 0;
  struct mail *mail;

  mail = (struct mail *) calloc(1, sizeof(struct mail ));
  strcpy(mail->to, "ALLE!ALLE");
D 51
  if (scanf("%*s%s", mail->from) != 1) halt;
  if (!getstring(line)) halt;
E 51
I 51
  if (scanf("%*s%s", mail->from) != 1) halt();
  if (!getstring(line)) halt();
E 51
  while (getstring(line))
    switch (state) {
    case 0:
      get_header_value("Subject:", line, mail->subject);
      get_header_value("Bulletin-ID:", line, mail->bid);
      get_header_value("Message-ID:", line, mail->mid);
      if (*line) continue;
      state = 1;
    case 1:
      if (!*line) continue;
      state = 2;
    case 2:
      append_line(mail, line);
    }
  route_mail(mail);
}

/*---------------------------------------------------------------------------*/

static void rnews()
{

  char  line[1024];
  int  n;
  int  state = 0;
  struct mail *mail;

  while (fgets(line, sizeof(line), stdin)) {
    mail = (struct mail *) calloc(1, sizeof(struct mail ));
    strcpy(mail->to, "ALLE!ALLE");
D 51
    if (strncmp(line, "#! rnews ", 9)) halt;
E 51
I 51
    if (strncmp(line, "#! rnews ", 9)) halt();
E 51
    n = atoi(line + 9);
    while (n > 0) {
D 51
      if (!fgets(line, n < sizeof(line) ? n + 1 : (int) sizeof(line), stdin)) halt;
E 51
I 51
      if (!fgets(line, n < sizeof(line) ? n + 1 : (int) sizeof(line), stdin)) halt();
E 51
      n -= strlen(line);
      strtrim(line);
      switch (state) {
      case 0:
	get_header_value("Path:", line, mail->from);
	get_header_value("Subject:", line, mail->subject);
	get_header_value("Bulletin-ID:", line, mail->bid);
	get_header_value("Message-ID:", line, mail->mid);
	if (*line) continue;
	state = 1;
      case 1:
	if (!*line) continue;
	state = 2;
      case 2:
	append_line(mail, line);
      }
    }
    route_mail(mail);
  }
}

/*---------------------------------------------------------------------------*/

E 48
E 11
E 4
static void b_cmd()
{
I 11
  if (arg[0][1]) {
    unknown_command();
    return;
  }
E 11
E 2
D 44
  puts("BBS mode terminated, returning to UNIX.");
E 44
I 44
  puts("BBS mode terminated.");
E 44
  exit(0);
}

D 2
/*****************************************************************************/
E 2
I 2
/*---------------------------------------------------------------------------*/
E 2

I 27
static void c_cmd()
{

  char  *tempfile = "index.tmp";
  int  delete;
  int  f;
  long  keepdate;
  struct index index;
  struct stat statbuf;

  if (arg[0][1] || !superuser) {
    unknown_command();
    return;
  }
  keepdate = time(0) - 90l * 24l * 60l * 60l;
D 51
  if ((f = open(tempfile, O_WRONLY | O_CREAT | O_EXCL, 0644)) < 0) halt;
  if (lseek(findex, 0l, 0)) halt;
E 51
I 51
  if ((f = open(tempfile, O_WRONLY | O_CREAT | O_EXCL, 0644)) < 0) halt();
  if (lseek(findex, 0l, 0)) halt();
E 51
  while (read(findex, (char *) &index, sizeof(struct index )) == sizeof(struct index )) {
    delete = (index.mesg == 0 && *index.bid == '\0')      ||
	     (index.mesg == 0 && index.date < keepdate)   ||
	     (index.type == 'P' && index.date < keepdate) ||
	     (index.status == 'F');
    if (index.mesg) {
      index.size = (delete || stat(filename(index.mesg), &statbuf)) ? 0 : statbuf.st_size;
      if (!index.size) {
	delete = 1;
	unlink(filename(index.mesg));
      }
    }
    if (!delete)
D 51
      if (write(f, (char *) &index, sizeof(struct index )) != sizeof(struct index )) halt;
E 51
I 51
      if (write(f, (char *) &index, sizeof(struct index )) != sizeof(struct index )) halt();
E 51
  }
D 51
  if (close(f)) halt;
  if (close(findex)) halt;
  if (unlink("index")) halt;
  if (link(tempfile, "index")) halt;
  if (unlink(tempfile)) halt;
E 51
I 51
  if (close(f)) halt();
  if (close(findex)) halt();
  if (rename(tempfile, "index")) halt();
E 51
  exit(0);
}

/*---------------------------------------------------------------------------*/

E 27
I 4
static void f_cmd()
{

  FILE * fp;
  char  buf[1024];
  int  c;
I 52
  int  found;
E 52
I 43
  int  l;
E 43
  struct index index;
D 6
  struct seq seq;
E 6
  struct tm *tm;

D 21
  if (arg[0][1] != '>' || !hostmode) return;
E 21
I 21
  if (strcmp(arg[0], "f>") || !hostmode) {
    unknown_command();
    return;
  }
E 21
D 6
  get_seq(&seq);
E 6
D 51
  if (lseek(findex, 0l, 0)) halt;
E 51
I 51
  if (lseek(findex, 0l, 0)) halt();
I 52
  found = 0;
E 52
E 51
D 26
  while (read(findex, (char *) & index, sizeof(struct index )) == sizeof(struct index ))
    if (index.mesg > seq.forw) {
D 10
      printf("SB %s%s%s < %s%s%s\n", index.to, *index.at ? " @ " : "", index.at, index.from, *index.bid ? " $" : "", index.bid);
      getstring(buf);
      switch (*strlwc(buf)) {
      case 'o':
	puts(index.subject);
	tm = gmtime(&index.date);
	printf("R:%02d%02d%02d/%02d%02dz @:DK5SG #%d <%s [Gaertringen,JN48KP]\n", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, index.mesg, index.from);
	if (!(fp = fopen(filename(index.mesg), "r"))) halt;
	while ((c = getc(fp)) != EOF) putchar(c);
	fclose(fp);
	puts("/EX");
      case 'n':
E 10
I 10
D 21
      if (!host_in_header(filename(index.mesg), loginname)) {
	printf("SB %s%s%s < %s%s%s\n", index.to, *index.at ? " @ " : "", index.at, index.from, *index.bid ? " $" : "", index.bid);
E 21
I 21
      if ((*index.bid || calleq(index.at, loginname)) && !host_in_header(filename(index.mesg), loginname)) {
	printf("S%c %s%s%s < %s%s%s\n", index.type, index.to, *index.at ? " @ " : "", index.at, index.from, *index.bid ? " $" : "", index.bid);
E 26
I 26
  while (read(findex, (char *) &index, sizeof(struct index )) == sizeof(struct index )) {
D 28
    if ((*index.bid && seq.forw < index.mesg || index.status != 'F' && can_forward(index.at)) && !host_in_header(filename(index.mesg), loginname)) {
E 28
I 28
D 29
    if (index.mesg > seq.forw &&
       (*index.bid || index.status != 'F' && can_forward(index.at)) &&
       !host_in_header(filename(index.mesg), loginname)) {
E 29
I 29
D 48
    if ((*index.bid && index.mesg > seq.forw || !*index.bid && index.mesg && index.status != 'F' && can_forward(index.at)) &&
E 48
I 48
    if ((index.status == '$' && index.mesg > seq.forw ||
	 index.status != '$' && index.status != 'F' && index.mesg && can_forward(index.at)) &&
E 48
	!host_in_header(filename(index.mesg), loginname)) {
I 52
      found = 1;
E 52
E 29
E 28
      printf("S%c %s%s%s < %s%s%s\n", index.type, index.to, *index.at ? " @ " : "", index.at, index.from, *index.bid ? " $" : "", index.bid);
      getstring(buf);
      switch (*strlwc(buf)) {
      case 'o':
	puts(index.subject);
	tm = gmtime(&index.date);
D 33
	printf("R:%02d%02d%02d/%02d%02dz @:DK5SG #%d [Gaertringen,JN48KP]\n", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, index.mesg);
E 33
I 33
D 35
	printf("R:%02d%02d%02d/%02d%02dz %d@DK5SG  [Gaertringen,JN48KP]\n", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, index.mesg);
E 35
I 35
D 51
	printf("R:%02d%02d%02d/%02d%02dz %d@DB0SAO  [Gaertringen,JN48KP]\n", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, index.mesg);
E 35
E 33
	if (!(fp = fopen(filename(index.mesg), "r"))) halt;
E 51
I 51
	printf("R:%02d%02d%02d/%02d%02dz %d@%s %s\n",
	       tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
	       tm->tm_hour, tm->tm_min, index.mesg, myhostname, mydesc);
	if (!(fp = fopen(filename(index.mesg), "r"))) halt();
E 51
	while ((c = getc(fp)) != EOF) putchar(c);
	fclose(fp);
D 41
	puts("/EX");
E 41
I 41
	puts("\032");
E 41
E 26
E 21
E 10
D 43
	getstring(buf);
D 10
	if (strncmp(strlwc(buf), "f>", 2)) return;
	seq.forw = index.mesg;
D 6
	put_seq(&seq);
E 6
I 6
	put_seq();
E 6
	break;
      default:
	return;
E 10
I 10
D 26
	switch (*strlwc(buf)) {
	case 'o':
	  puts(index.subject);
	  tm = gmtime(&index.date);
D 18
	  printf("R:%02d%02d%02d/%02d%02dz @:DK5SG #%d <%s [Gaertringen,JN48KP]\n", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, index.mesg, index.from);
E 18
I 18
	  printf("R:%02d%02d%02d/%02d%02dz @:DK5SG #%d [Gaertringen,JN48KP]\n", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, index.mesg);
E 18
	  if (!(fp = fopen(filename(index.mesg), "r"))) halt;
	  while ((c = getc(fp)) != EOF) putchar(c);
	  fclose(fp);
	  puts("/EX");
I 21
	  getstring(buf);
	  if (strcmp(strlwc(buf), "f>")) return;
	  if (index.status == 'N' || index.status == 'Y') {
	    index.status = 'F';
	    if (lseek(findex, (long) (-sizeof(struct index )), 1) < 0) halt;
	    if (write(findex, (char *) &index, sizeof(struct index )) != sizeof(struct index )) halt;
	  }
	  break;
E 21
	case 'n':
	  getstring(buf);
D 21
	  if (strncmp(strlwc(buf), "f>", 2)) return;
E 21
I 21
	  if (strcmp(strlwc(buf), "f>")) return;
E 21
	  break;
	default:
	  return;
E 26
I 26
D 42
	if (strcmp(strlwc(buf), "f>")) return;
E 42
I 42
	if (buf[strlen(buf)-1] != '>') return;
E 43
I 43
	do {
	  getstring(buf);
	  l = strlen(buf);
	} while (!l || buf[l-1] != '>');
E 43
E 42
	if (index.status == 'N' || index.status == 'Y') {
	  index.status = 'F';
D 51
	  if (lseek(findex, (long) (-sizeof(struct index )), 1) < 0) halt;
	  if (write(findex, (char *) &index, sizeof(struct index )) != sizeof(struct index )) halt;
E 51
I 51
	  if (lseek(findex, (long) (-sizeof(struct index )), 1) < 0) halt();
	  if (write(findex, (char *) &index, sizeof(struct index )) != sizeof(struct index )) halt();
E 51
E 26
	}
I 26
	break;
      case 'n':
D 43
	getstring(buf);
D 42
	if (strcmp(strlwc(buf), "f>")) return;
E 42
I 42
	if (buf[strlen(buf)-1] != '>') return;
E 43
I 43
	do {
	  getstring(buf);
	  l = strlen(buf);
	} while (!l || buf[l-1] != '>');
E 43
E 42
	break;
      default:
D 52
	return;
E 52
I 52
	exit(1);
E 52
E 26
E 10
      }
I 26
    }
    if (seq.forw < index.mesg) {
E 26
I 10
      seq.forw = index.mesg;
      put_seq();
E 10
    }
I 26
  }
E 26
D 44
  puts("B");
E 44
D 52
  exit(0);
E 52
I 52
  if (!found) exit(0);
I 53
  putchar('F');
E 53
E 52
}

/*---------------------------------------------------------------------------*/

E 4
D 2
void h_cmd()
E 2
I 2
static void h_cmd()
E 2
{
D 11
  puts("\nCommand summary:\n");

  puts("? - Display this help text.");
I 4
  puts("A - Abort current activity.");
E 4
  puts("B - Bye, terminate BBS mode and return to UNIX.");
  puts("H - Display this help text.");
I 4
  puts("I - Display information about the system.");
  if (superuser) puts("K - Kill messages.");
  puts("L - List message headers.");
  puts("R - Read messages.");
E 4
  puts("S - Send a message.");
I 5
  puts("V - Display BBS version and status.");
E 5

E 11
  putchar('\n');
I 11
  switch (arg[0][1] ? arg[0][1] : *arg[1]) {
  case '?':
    puts("? - Display help.");
    putchar('\n');
    puts("? [cmd]");
    break;
  case 'a':
    puts("A - Abort current activity.");
    break;
  case 'b':
D 44
    puts("B - Bye, terminate BBS mode and return to UNIX.");
E 44
I 44
    puts("B - Bye, terminate BBS mode.");
E 44
    break;
  case 'h':
    puts("H - Display help.");
    putchar('\n');
    puts("H [cmd]");
    break;
  case 'i':
    puts("I - Display information about the system.");
    break;
  case 'k':
    puts("K - Kill messages.");
    putchar('\n');
    puts("K msg ...");
I 21
    puts("KM");
E 21
    break;
  case 'l':
    puts("L - List message headers.");
    putchar('\n');
    puts("L         [first [last]]");
    puts("L< from   [first [last]]");
    puts("L> to     [first [last]]");
    puts("L@ at     [first [last]]");
    puts("LB        [first [last]]");
    puts("LL count  [first [last]]");
    puts("LM        [first [last]]");
I 21
    puts("LN        [first [last]]");
E 21
    puts("LS substr [first [last]]");
    break;
I 44
  case 'q':
    puts("Q - Quit, terminate BBS mode.");
    break;
E 44
  case 'r':
    puts("R - Read messages.");
    putchar('\n');
    puts("R msg ...");
I 21
    puts("RM");
    puts("RN");
E 21
    break;
  case 's':
    puts("S - Send a message.");
    putchar('\n');
    puts("S  to [@ at] [< from] [$bid]");
    puts("SB to [@ at] [< from] [$bid]");
    puts("SP to [@ at] [< from] [$bid]");
    break;
  case 'v':
    puts("V - Display BBS version and status.");
    break;
  default:
    puts("Command summary:");
    putchar('\n');
    puts("? - Display help.");
    puts("A - Abort current activity.");
D 44
    puts("B - Bye, terminate BBS mode and return to UNIX.");
E 44
I 44
    puts("B - Bye, terminate BBS mode.");
E 44
    puts("H - Display help.");
    puts("I - Display information about the system.");
    puts("K - Kill messages.");
    puts("L - List message headers.");
I 44
    puts("Q - Quit, terminate BBS mode.");
E 44
    puts("R - Read messages.");
    puts("S - Send a message.");
    puts("V - Display BBS version and status.");
    putchar('\n');
    puts("Try ? cmd for more help about cmd.");
    break;
  }
  putchar('\n');
E 11
}

D 2
/*****************************************************************************/
E 2
I 2
/*---------------------------------------------------------------------------*/
E 2

I 21
static void host_cmd()
{
  register char  **p;

D 55
  if (!strncmp(arg[0], "[mbl", 4))
    for (p = hosts; *p; p++)
D 38
      if (!strcmp(*p, loginname)) {
	hostmode = 1;
	return;
      }
E 38
I 38
D 51
      for (; *p; p++)
	if (!strcmp(*p, loginname)) {
	  hostmode = 1;
	  return;
	}
E 51
I 51
      if (!strcmp(*p, loginname)) {
	hostmode = 1;
	return;
      }
E 55
I 55
  for (p = hosts; *p; p++)
    if (calleq(*p, loginname)) {
      hostmode = 1;
      return;
    }
E 55
E 51
E 38
  unknown_command();
}

/*---------------------------------------------------------------------------*/

E 21
I 4
static void i_cmd()
{

  FILE * fp;
  int  c;

I 11
  if (arg[0][1]) {
    unknown_command();
    return;
  }
E 11
D 51
  if (!(fp = fopen(INFOFILE, "r"))) halt;
E 51
I 51
  if (!(fp = fopen(INFOFILE, "r"))) halt();
E 51
  while ((c = getc(fp)) != EOF) {
    putchar(c);
    if (c == '\n' && check_abort()) break;
  }
  fclose(fp);
}

/*---------------------------------------------------------------------------*/

I 21
static void do_kill(index)
struct index *index;
{
  int  mesg;

  if (superuser || calleq(index->from, loginname) || calleq(index->to, loginname)) {
D 51
    if (unlink(filename(mesg = index->mesg))) halt;
E 51
I 51
    if (unlink(filename(mesg = index->mesg))) halt();
E 51
    index->mesg = 0;
D 51
    if (lseek(findex, (long) (-sizeof(struct index )), 1) < 0) halt;
    if (write(findex, (char *) index, sizeof(struct index )) != sizeof(struct index )) halt;
E 51
I 51
    if (lseek(findex, (long) (-sizeof(struct index )), 1) < 0) halt();
    if (write(findex, (char *) index, sizeof(struct index )) != sizeof(struct index )) halt();
E 51
    printf("*** Msg # %d - Killed\n", mesg);
  } else
    printf("You are not authorized to kill Msg # %d\n", index->mesg);
}

/*---------------------------------------------------------------------------*/

E 21
static void k_cmd()
{

I 21
  int  found;
E 21
  int  i;
  int  mesg;
  struct index index;

I 21
  if (!strcmp(arg[0], "km")) {
    found = 0;
D 51
    if (lseek(findex, 0l, 0)) halt;
E 51
I 51
    if (lseek(findex, 0l, 0)) halt();
E 51
    while (read(findex, (char *) & index, sizeof(struct index )) == sizeof(struct index ))
      if (index.mesg && calleq(index.to, loginname) && (index.status == 'Y' || index.status == 'F')) {
	do_kill(&index);
	found = 1;
      }
    if (!found) puts("No matching message found.");
    return;
  }

E 21
I 11
  if (arg[0][1]) {
    unknown_command();
    return;
  }
E 11
D 21
  if (!superuser) {
D 12
    puts("Permission denied.");
E 12
I 12
    puts("You are not authorized to use the K command.  Sorry.");
E 12
    return;
  }
  for (i = 1; i < NARGS; i++) {
    if (!*arg[i]) break;
    if ((mesg = atoi(arg[i])) == lastmesg()) {
      puts("You cannot kill the last message.");
      continue;
E 21
I 21
  for (i = 1; i < NARGS && *arg[i]; i++) {
    found = 0;
    if ((mesg = atoi(arg[i])) > 0) {
D 51
      if (lseek(findex, 0l, 0)) halt;
E 51
I 51
      if (lseek(findex, 0l, 0)) halt();
E 51
      while (read(findex, (char *) & index, sizeof(struct index )) == sizeof(struct index ))
	if (index.mesg == mesg) {
	  do_kill(&index);
	  found = 1;
	  break;
	}
E 21
    }
D 21
    if (mesg <= 0 || unlink(filename(mesg))) {
      printf("No such message: '%s'.\n", arg[i]);
      continue;
    }
    if (lseek(findex, 0l, 0)) halt;
    for (; ; ) {
      if (read(findex, (char *) & index, sizeof(struct index )) != sizeof(struct index )) halt;
      if (index.mesg == mesg) break;
    }
D 9
    memset((char *) & index, 0, sizeof(struct index ));
E 9
I 9
    index.mesg = 0;
E 9
    if (lseek(findex, (long) (-sizeof(struct index )), 1) < 0) halt;
    if (write(findex, (char *) & index, sizeof(struct index )) != sizeof(struct index )) halt;
    printf("Msg # %d removed.\n", mesg);
E 21
I 21
    if (!found) printf("No such message: '%s'.\n", arg[i]);
E 21
  }
}

/*---------------------------------------------------------------------------*/

static void l_cmd()
{

D 6
  char  *at = NULL;
  char  *from = NULL;
  char  *to = NULL;
  int  found = 0;
  int  i = 1;
  int  max = 32767;
  int  min = 0;
  int  num = 32767;
E 6
I 6
D 11
  char  *to, *at, *from;
E 11
I 11
  char  *to, *at, *from, *sub;
E 11
I 7
  char  buf[1024];
E 7
D 11
  int  found;
E 11
I 11
D 21
  int  found, update_seq;
E 21
I 21
D 24
  int  found, newonly, update_seq;
E 24
I 24
  int  found, update_seq, status, type;
E 24
E 21
E 11
  int  i;
  int  min, max, num;
E 6
  int  tmp;
  struct index index;
D 6
  struct seq seq;
E 6

D 6
  get_seq(&seq);
E 6
I 6
D 11
  to = at = from = NULL;
  found = 0;
  min = seq.list + 1;
E 11
I 11
  to = at = from = sub = NULL;
D 21
  found = update_seq = 0;
E 21
I 21
D 24
  found = newonly = update_seq = 0;
E 24
I 24
  found = update_seq = status = type = 0;
E 24
E 21
  min = 1;
E 11
  max = num = 32767;
  i = 1;
E 6
  switch (arg[0][1]) {
I 11
  case '\0':
    min = seq.list + 1;
    update_seq = !*arg[1];
    break;
E 11
D 6
  case '\0':
    min = seq.list + 1;
    break;
E 6
  case '<':
D 7
    from = arg[i++];
E 7
I 7
D 21
    from = strupc(arg[i++]);
E 21
I 21
    from = arg[i++];
E 21
E 7
    break;
  case '>':
D 7
    to = arg[i++];
E 7
I 7
D 21
    to = strupc(arg[i++]);
E 21
I 21
    to = arg[i++];
E 21
E 7
    break;
  case '@':
D 7
    at = arg[i++];
E 7
I 7
D 21
    at = strupc(arg[i++]);
E 21
I 21
    at = arg[i++];
E 21
E 7
    break;
I 11
  case 'b':
I 24
    type = 'B';
E 24
    break;
E 11
  case 'l':
I 6
D 11
    min = 1;
E 11
E 6
    num = atoi(arg[i++]);
    break;
I 21
  case 'n':
D 24
    newonly = 1;
E 24
I 24
    status = 'N';
E 24
E 21
  case 'm':
D 7
    to = loginname;
    break;
E 7
D 11
  case 'n':
D 7
    to = loginname;
E 7
I 7
    to = strupc(strcpy(buf,loginname));
E 11
I 11
D 21
    to = strupc(strcpy(buf, loginname));
E 21
I 21
    to = loginname;
E 21
E 11
E 7
    break;
I 11
  case 's':
D 21
    sub = strupc(arg[i++]);
E 21
I 21
    sub = arg[i++];
E 21
    break;
  default:
    unknown_command();
    return;
E 11
  }
D 7
  strupc(from);
  strupc(to);
  strupc(at);
E 7
  if (tmp = atoi(arg[i++])) min = tmp;
  if (tmp = atoi(arg[i++])) max = tmp;
  if (min > max) {
    tmp = max;
    max = min;
    min = tmp;
  }
  if (lseek(findex, (long) (-sizeof(struct index )), 2) >= 0) {
    for (; ; ) {
      if (check_abort()) return;
D 21
      if (read(findex, (char *) & index, sizeof(struct index )) != sizeof(struct index )) halt;
E 21
I 21
D 51
      if (read(findex, (char *) &index, sizeof(struct index )) != sizeof(struct index )) halt;
E 51
I 51
      if (read(findex, (char *) &index, sizeof(struct index )) != sizeof(struct index )) halt();
E 51
E 21
D 11
      if (index.mesg && index.mesg < min) break;
      if (index.mesg && index.mesg <= max && !(from && strcmp(from, index.from)) && !(to && strcmp(to, index.to)) && !(at && strcmp(at, index.at))) {
E 11
I 11
      if (index.mesg >= min && index.mesg <= max &&
D 21
	  (!from || !strcmp(from, index.from))   &&
	  (!to   || !strcmp(to, index.to))       &&
	  (!at   || !strcmp(at, index.at))       &&
	  (!sub  || strpos(strupc(strcpy(buf, index.subject)), sub))) {
E 21
I 21
	  read_allowed(&index)                   &&
D 24
	  (!newonly || index.status == 'N')      &&
E 24
I 24
	  (!type    || type == index.type)       &&
	  (!status  || status == index.status)   &&
E 24
	  (!from    || calleq(from, index.from)) &&
	  (!to      || calleq(to, index.to))     &&
	  (!at      || calleq(at, index.at))     &&
	  (!sub     || strpos(strlwc(strcpy(buf, index.subject)), sub))) {
E 21
E 11
	if (!found) {
D 50
	  puts(" Msg# TS  Size To     @ BBS  From   Date    Subject");
E 50
I 50
	  puts("Msg# TS  Size To       @ BBS    From     Date   Subject");
E 50
	  found = 1;
	}
D 50
	printf("%5d %c%c %5d %-6s%c%-6s %-6s %-6.6s  %.35s\n", index.mesg, index.type, index.status, index.size, index.to, *index.at ? '@' : ' ', index.at, index.from, clock_to_str(index.date), index.subject);
E 50
I 50
D 51
	printf("%4d %c%c %5d %-8s%c%-8s %-8s %-6.6s %.31s\n", index.mesg, index.type, index.status, index.size, index.to, *index.at ? '@' : ' ', index.at, index.from, clock_to_str(index.date), index.subject);
E 51
I 51
D 54
	printf("%4d %c%c %5ld %-8s%c%-8s %-8s %-6.6s %.31s\n", index.mesg, index.type, index.status, index.size, index.to, *index.at ? '@' : ' ', index.at, index.from, clock_to_str(index.date), index.subject);
E 54
I 54
	printf("%4d %c%c %5ld %-8s%c%-8s %-8s %-6.6s %.31s\n", index.mesg, index.type, index.status, index.size, index.to, *index.at ? '@' : ' ', index.at, index.from, timestr(index.date), index.subject);
E 54
E 51
E 50
D 11
	if (seq.list < index.mesg) {
E 11
I 11
	if (update_seq && seq.list < index.mesg) {
E 11
	  seq.list = index.mesg;
D 6
	  put_seq(&seq);
E 6
I 6
	  put_seq();
E 6
	}
	if (--num <= 0) break;
      }
      if (lseek(findex, -2l * sizeof(struct index ), 1) < 0) break;
    }
  }
D 6
  if (!found) puts("No matching message found.");
E 6
I 6
D 11
  if (!found) puts(*arg[1] ? "No matching message found." : "No new messages since last L command.");
E 11
I 11
  if (!found) puts(update_seq ? "No new messages since last L command." : "No matching message found.");
E 11
E 6
}

/*---------------------------------------------------------------------------*/

D 21
static void r_cmd()
E 21
I 21
static int  do_read(index)
struct index *index;
E 21
{

  FILE * fp;
D 21
  int  c;
E 21
I 21
D 48
  char  *p, *q;
E 48
I 48
  char  *p;
E 48
  char  buf[1024];
  char  path[1024];
  int  inheader;

D 51
  if (!(fp = fopen(filename(index->mesg), "r"))) halt;
E 51
I 51
  if (!(fp = fopen(filename(index->mesg), "r"))) halt();
E 51
D 48
  printf("Msg # %d  Type:%c  Stat:%c  To: %s%s%s  From: %s  Date: %s\n", index->mesg, index->type, index->status, index->to, *index->at ? " @" : "", index->at, index->from, clock_to_str(index->date));
E 48
I 48
D 50
  printf("Msg # %d  Type:%c  Stat:%c  To: %s%s%s  From: %s  Date: %s\n",
E 50
I 50
  printf("Msg# %d Type:%c Stat:%c To: %s%s%s From: %s Date: %s\n",
E 50
	 index->mesg,
	 index->type,
	 index->status,
	 index->to,
	 *index->at ? " @" : "",
	 index->at,
	 index->from,
D 54
	 clock_to_str(index->date));
E 54
I 54
	 timestr(index->date));
E 54
E 48
  if (*index->subject) printf("Subject: %s\n", index->subject);
  if (*index->bid) printf("Bulletin ID: %s\n", index->bid);
  *path = '\0';
  inheader = 1;
  while (fgets(buf, sizeof(buf), fp)) {
    if (check_abort()) {
      fclose(fp);
      return 0;
    }
D 32
    if (inheader && buf[0] == 'R' && buf[1] == ':' && isdigit(buf[2] & 0xff) && (p = strpos(buf, " @:"))) {
      p += 3;
E 32
I 32
D 47
    if (inheader && buf[0] == 'R' && buf[1] == ':' && isdigit(buf[2] & 0xff) && (p = strchr(buf, '@'))) {
E 47
I 47
D 48
    if (inheader && buf[0] == 'R' && buf[1] == ':' && (p = strchr(buf, '@'))) {
E 47
      p++;
I 40
      while (isspace(*p & 0xff)) p++;
E 40
      if (*p == ':') p++;
E 32
      for (q = p; isalnum(*q & 0xff); q++) ;
      *q = '\0';
      strcat(path, *path ? "!" : "Path: ");
      strcat(path, p);
      continue;
    }
E 48
    if (inheader) {
I 48
      if (p = get_host_from_header(buf)) {
	strcat(path, *path ? "!" : "Path: ");
	strcat(path, p);
	continue;
      }
E 48
      if (*path) puts(path);
      inheader = 0;
    }
    fputs(buf, stdout);
  }
  putchar('\n');
  fclose(fp);
  if (index->status == 'N' && (index->type != 'P' || calleq(index->to, loginname))) {
    index->status = 'Y';
D 51
    if (lseek(findex, (long) (-sizeof(struct index )), 1) < 0) halt;
    if (write(findex, (char *) index, sizeof(struct index )) != sizeof(struct index )) halt;
E 51
I 51
    if (lseek(findex, (long) (-sizeof(struct index )), 1) < 0) halt();
    if (write(findex, (char *) index, sizeof(struct index )) != sizeof(struct index )) halt();
E 51
  }
  return 1;
}

/*---------------------------------------------------------------------------*/

static void r_cmd()
{

  int  found;
E 21
  int  i;
  int  mesg;
  struct index index;

I 21
  if (!strcmp(arg[0], "rm") || !strcmp(arg[0], "rn")) {
    found = 0;
D 51
    if (lseek(findex, 0l, 0)) halt;
E 51
I 51
    if (lseek(findex, 0l, 0)) halt();
E 51
    while (read(findex, (char *) & index, sizeof(struct index )) == sizeof(struct index ))
      if (index.mesg && calleq(index.to, loginname) && (arg[0][1] == 'm' || index.status == 'N')) {
	if (!do_read(&index)) return;
	found = 1;
      }
    if (!found) puts("No matching message found.");
    return;
  }

E 21
I 11
  if (arg[0][1]) {
    unknown_command();
    return;
  }
E 11
D 21
  for (i = 1; i < NARGS; i++) {
    if (!*arg[i]) break;
    if ((mesg = atoi(arg[i])) <= 0 || !(fp = fopen(filename(mesg), "r"))) {
      printf("No such message: '%s'.\n", arg[i]);
      continue;
E 21
I 21
  for (i = 1; i < NARGS && *arg[i]; i++) {
    found = 0;
    if ((mesg = atoi(arg[i])) > 0) {
D 51
      if (lseek(findex, 0l, 0)) halt;
E 51
I 51
      if (lseek(findex, 0l, 0)) halt();
E 51
      while (read(findex, (char *) & index, sizeof(struct index )) == sizeof(struct index ))
	if (index.mesg == mesg && read_allowed(&index)) {
	  if (!do_read(&index)) return;
	  found = 1;
	  break;
	}
E 21
    }
D 21
    if (lseek(findex, 0l, 0)) halt;
    for (; ; ) {
      if (read(findex, (char *) & index, sizeof(struct index )) != sizeof(struct index )) halt;
      if (index.mesg == mesg) break;
    }
    printf("Msg # %d  Type:%c  Stat:%c  To: %s%s%s  From: %s  Date: %s\n", mesg, index.type, index.status, index.to, *index.at ? " @" : "", index.at, index.from, clock_to_str(index.date));
    while ((c = getc(fp)) != EOF) {
      putchar(c);
      if (c == '\n' && check_abort()) {
	i = NARGS;
	break;
      }
    }
    fclose(fp);
E 21
I 21
    if (!found) printf("No such message: '%s'.\n", arg[i]);
E 21
  }
}

/*---------------------------------------------------------------------------*/

E 4
D 2
void s_cmd()
E 2
I 2
D 48
static void s_cmd()
E 2
{

D 4
  FILE *fp;
  char from[1024];
  char line[1024];
  char subject[1024];
  char to[1024];
E 4
I 4
  FILE * fp;
I 30
  char  *p;
E 30
  char  at[1024];
  char  bid[1024];
  char  from[1024];
I 34
  char  from_at[1024];
E 34
  char  line[1024];
  char  subject[1024];
I 15
  char  tempfile[80];
E 15
  char  to[1024];
  char  to_at[1024];
D 21
  char  type;
E 21
  int  i;
I 21
  int  status;
  int  type;
E 21
  struct index index;
E 4

I 11
D 19
  switch (arg[0][1]) {
  case '\0':
  case 'b':
  case 'p':
    break;
  default:
E 19
I 19
  if (strlen(arg[0]) > 2) {
E 19
    unknown_command();
    return;
  }
I 20
D 21

  if (!hostmode) {
    puts("This command is currently not available, sorry.");
    return;
  }

E 21
E 20
E 11
D 31
  strcpy(to, utsname.nodename);
D 4
  strcpy(from, logname);
  if (*arg[1])                   strcpy(to, arg[1]);
  if (*arg[3] && *arg[2] == '@') sprintf(to, "%s@%s", arg[1], arg[3]);
  if (*arg[3] && *arg[2] == '<') sprintf(from, "%s@%s", arg[3], logname);
  if (*arg[5] && *arg[4] == '<') sprintf(from, "%s@%s", arg[5], logname);
  puts("Enter subject:");
  gets(subject);
D 2
  sprintf(line, "/usr/lib/sendmail -oi -oem -f %s %s", from, to);
E 2
I 2
  sprintf(line, "/usr/lib/sendmail -oi -oem -f %s %s",
D 3
	  from, strpos(to, "alle") ? "alle" : to);
E 3
I 3
	  from, strpos(to, "alle") ? utsname.nodename : to);
E 3
E 2
  fp = popen(line, "w");
  fprintf(fp, "From: %s\nTo: %s\nSubject: %s\n\n", from, to, subject);
  puts("Enter message:");
  for (;;) {
    gets(line);
    if (*line == '\032') break;
    if (!strcmp(line, "/EX")) break;
    if (!strcmp(line, "/ex")) break;
E 4
I 4
  *at = '\0';
  strcpy(from, loginname);
  *bid = '\0';
E 31
I 31
  *to = *at = *from = *bid = '\0';
E 31
  if (*arg[1]) strcpy(to, arg[1]);
  for (i = 2; i < NARGS; i++)
    switch (*arg[i]) {
    case '@':
      strcpy(at, arg[i][1] ? arg[i] + 1 : arg[++i]);
      break;
    case '<':
      strcpy(from, arg[i][1] ? arg[i] + 1 : arg[++i]);
I 21
D 30
      if (!(hostmode || superuser)) strcpy(from, loginname);
E 30
E 21
      break;
    case '$':
      strcpy(bid, arg[i][1] ? arg[i] + 1 : arg[++i]);
D 30
      bid[LEN_BID] = '\0';
      strupc(bid);
E 30
      break;
    }
I 30
  if (p = strchr(to, '@')) {
    *p++ = '\0';
    strcpy(at, p);
  }
  if (p = strchr(at, '<')) {
    *p++ = '\0';
    strcpy(from, p);
  }
  if (p = strchr(from, '$')) {
    *p++ = '\0';
    strcpy(bid, p);
  }
D 31
  if (!(hostmode || superuser)) strcpy(from, loginname);
E 31
I 31
D 33
  if (!*to) strcpy(to, utsname.nodename);
E 33
I 33
  if (!*to) strcpy(to, "ALLE");
E 33
  if (!*from || !hostmode && !superuser) strcpy(from, loginname);
E 31
  bid[LEN_BID] = '\0';
  strupc(bid);
E 30
  strcpy(to_at, to);
  if (*at) {
    strcat(to_at, "@");
    strcat(to_at, at);
  }
I 34
  sprintf(from_at, "%s@%s", from, utsname.nodename);
  strupc(from_at);
E 34
D 19
  type = (arg[0][1] == 'b' || !strncmp(to, "all", 3) || !strncmp(at, "all", 3)) ? 'B' : 'P';
E 19
I 19
D 21
  type = (arg[0][1] != 'p' || !strncmp(to, "all", 3) || !strncmp(at, "all", 3)) ? 'B' : 'P';
E 19
  if (type == 'B' && *bid) {
E 21
I 21
D 25
  type = callvalid(to) ? 'P' : 'B';
  if (type == 'P')
    status = 'N';
  else if (callvalid(at))
    status = 'N';
  else if (*at)
    status = '$';
  else if (*bid)
    status = '$';
  else
    status = 'N';
E 25
I 25
  if (hostmode) {
    if (*bid) {
      type = 'B';
      status = '$';
    } else {
      type = callvalid(to) ? 'P' : 'B';
      status = 'N';
    }
  } else {
    type = callvalid(to) ? 'P' : 'B';
    if (type == 'P')
      status = 'N';
    else if (callvalid(at))
      status = 'N';
    else if (*at)
      status = '$';
    else if (*bid)
      status = '$';
    else
      status = 'N';
  }
E 25
  if (status != '$') *bid = '\0';
  if (*bid) {
E 21
    if (lseek(findex, 0l, 0)) halt;
    while (read(findex, (char *) & index, sizeof(struct index )) == sizeof(struct index ))
      if (!strcmp(bid, index.bid)) {
	printf("N - Already Have %s\n", bid);
	return;
      }
  }
  puts(hostmode ? "OK - Snd # 1" : "Enter subject:");
  getstring(subject);
D 12
  if (!(fp = fopen(tempfile, "w"))) halt;
E 12
I 12
D 15
  fp = create_tempfile();
E 15
I 15
  fp = create_tempfile(tempfile);
E 15
E 12
D 34
  if (type == 'P') fprintf(fp, "From: %s\nTo: %s\nSubject: %s\n\n", from, to_at, subject);
E 34
I 34
  if (type == 'P')
    fprintf(fp, "From: %s\nTo: %s\nSubject: %s\n\n", from, to_at, subject);
  else
    if (!hostmode) fprintf(fp, "From: %s\n\n", from_at);
E 34
  if (!hostmode) puts("Enter message: (terminate with ^Z or /EX)");
  for (; ; ) {
    if (!getstring(line) || *line == '\032' || !strcmp(line, "/EX") || !strcmp(line, "/ex")) break;
E 4
    fputs(line, fp);
    putc('\n', fp);
  }
D 4
  puts("Message accepted.");
  pclose(fp);
E 4
I 4
  fclose(fp);
D 10
  if (type == 'P') {
E 10
I 10
  if (host_in_header(tempfile, utsname.nodename)) {
D 22
    if (!hostmode) puts("Duplicate message, dropped.");
E 22
I 12
    if (unlink(tempfile)) halt;
I 22
    if (!hostmode) puts("Duplicate message, dropped.");
E 22
E 12
  } else if (type == 'P') {
E 10
    if (!hostmode) printf("Message sent to %s via MAIL.\n", to_at);
    switch (fork()) {
    case -1:
      halt;
    case 0:
      setpgrp();
      signal(SIGCLD, SIG_DFL);
I 12
      setuid(0);
      setgid(1);
E 12
      for (i = 0; i < _NFILE; i++) close(i);
      fopen(tempfile, "r");
      fopen("/dev/null", "r+");
      fopen("/dev/null", "r+");
      unlink(tempfile);
      execl("/usr/lib/sendmail", "/usr/lib/sendmail", "-oi", "-oem", "-f", from, to_at, 0);
      exit(1);
    }
  } else {
D 22
    if (!hostmode) puts("Message stored in BBS.");
E 22
D 15
    store(bid, type, subject, '$', to, at, from);
E 15
I 15
D 16
    store(tempfile, bid, type, subject, '$', to, at, from);
E 16
I 16
D 21
    store_in_bbs(tempfile, bid, type, subject, '$', to, at, from);
E 21
I 21
    store_in_bbs(tempfile, bid, type, subject, status, to, at, from);
E 21
E 16
E 15
D 22
    switch (fork()) {
    case -1:
      halt;
    case 0:
      setpgrp();
      signal(SIGCLD, SIG_DFL);
I 12
      setuid(0);
      setgid(1);
E 12
      for (i = 0; i < _NFILE; i++) close(i);
      fopen(tempfile, "r");
      fopen("/dev/null", "r+");
      fopen("/dev/null", "r+");
      unlink(tempfile);
D 15
      execl("/usr/contrib/bin/inotes", "/usr/contrib/bin/inotes", "-n", debug ? "junk" : "dnet.ham", "-t", subject, 0);
E 15
I 15
D 21
      execl("/usr/contrib/bin/inotes", "/usr/contrib/bin/inotes", "-n", debug ? "dk5sg.test" : "dnet.ham", "-t", subject, 0);
E 21
I 21
      execl("/usr/contrib/bin/inotes", "/usr/contrib/bin/inotes", "-n", debug ? "dk5sg.test" :  "dnet.ham", "-t", subject, 0);
E 21
E 15
      exit(1);
    }
E 22
I 22
    if (!hostmode) puts("Message stored in BBS.");
    if (status == '$')
      switch (fork()) {
      case -1:
	halt;
      case 0:
	setpgrp();
	signal(SIGCLD, SIG_DFL);
	setuid(0);
	setgid(1);
	for (i = 0; i < _NFILE; i++) close(i);
	fopen(tempfile, "r");
	fopen("/dev/null", "r+");
	fopen("/dev/null", "r+");
	unlink(tempfile);
	execl("/usr/contrib/bin/inotes", "/usr/contrib/bin/inotes", "-n", debug ? "dk5sg.test" :  "dnet.ham", "-t", subject, 0);
	exit(1);
      }
    else
      if (unlink(tempfile)) halt;
E 22
  }
E 4
}

D 2
/*****************************************************************************/
E 2
I 2
/*---------------------------------------------------------------------------*/
E 2

E 48
D 2
main()
E 2
I 2
D 4
int main()
E 4
I 4
static void v_cmd()
E 4
E 2
{
I 11
  if (arg[0][1]) {
    unknown_command();
    return;
  }
E 11
I 4
D 6
  struct seq seq;
E 4

D 4
  char line[1024];
  int i;
E 4
I 4
  get_seq(&seq);
E 6
D 12
  puts("Version: DK5SG BBS v%I% - %E% %U%");
E 12
I 12
D 34
  puts("Version: DK5SG-BBS v%I% - %E% %U%");
E 12
  printf("NxtMsg: %d  Active: %d  L-Msg: %d\n", lastmesg() + 1, numbmesg(), seq.list);
E 34
I 34
  puts("Version: DK5SG BBS v%I% - %E%");
  printf("NxtMsg: %d  Active: %d  L-Msg: %d\n", lastmesg() + 1, numbmesg(), seq.list + 1);
E 34
}
E 4

D 4
  setuid(0);
  setgid(1);
E 4
I 4
/*---------------------------------------------------------------------------*/
E 4

D 4
  uname(&utsname);
E 4
I 4
static void bbs()
{
E 4

D 4
  strcpy(logname, getenv("LOGNAME"));
E 4
I 4
  char  line[1024];
I 17
  char  quote;
E 17
  int  i;
  register char  *p;
E 4

D 4
  for (;;) {
    printf("%s de %s-BBS \007 >\n", logname, utsname.nodename);
    gets(line);
    make_lowercase(line);
    for (i=0; i<10; i++) *arg[i] = '\0';
    sscanf(line, "%s%s%s%s%s%s%s%s%s%s",
		 arg[0], arg[1], arg[2], arg[3], arg[4],
		 arg[5], arg[6], arg[7], arg[8], arg[9]);
E 4
I 4
D 33
  puts("[MBL320]");
E 33
I 33
  puts("[MBL-$]");
E 33
  for (; ; ) {
    if (hostmode)
D 52
      puts(">");
E 52
I 52
D 53
      puts("F>");
E 53
I 53
      puts(">");
E 53
E 52
    else
D 51
      printf("%s de %s-BBS \007 >\n", loginname, utsname.nodename);
E 51
I 51
      printf("%s de %s-BBS \007 >\n", loginname, myhostname);
E 51
D 11
    if (!getstring(line)) b_cmd();
E 11
I 11
    if (!getstring(line)) strcpy(line, "b");
E 11
    for (p = strlwc(line), i = 0; i < NARGS; i++) {
I 17
      quote = '\0';
E 17
D 21
      while (isspace(*p)) p++;
E 21
I 21
D 51
      while (isspace(*p & 0xff)) p++;
E 51
I 51
      while (isspace(uchar(*p))) p++;
E 51
E 21
I 17
      if (*p == '"' || *p == '\'') quote = *p++;
E 17
      arg[i] = p;
D 17
      while (*p && !isspace(*p)) p++;
E 17
I 17
      if (quote) {
	if (!(p = strchr(p, quote))) p = "";
      } else
D 21
	while (*p && !isspace(*p)) p++;
E 21
I 21
D 51
	while (*p && !isspace(*p & 0xff)) p++;
E 51
I 51
	while (*p && !isspace(uchar(*p))) p++;
E 51
E 21
E 17
      if (*p) *p++ = '\0';
    }
E 4
    switch (*arg[0]) {
D 4
    case '\0':          break;
    case  '?': h_cmd(); break;
    case  'b': b_cmd(); break;
    case  'h': h_cmd(); break;
    case  's': s_cmd(); break;
    default: printf("Unknown command '%s'.  Type ? for help.\n", arg[0]); break;
E 4
I 4
D 44
    case '\0' :
      break;
    case '?':
      h_cmd();
      break;
    case '[':
D 21
      hostmode = 1;
E 21
I 21
      host_cmd();
E 21
      break;
    case 'a':
      break;
    case 'b':
      b_cmd();
I 27
      break;
    case 'c':
      c_cmd();
E 27
      break;
    case 'f':
      f_cmd();
      break;
    case 'h':
      h_cmd();
      break;
    case 'i':
      i_cmd();
      break;
    case 'k':
      k_cmd();
      break;
    case 'l':
      l_cmd();
      break;
    case 'r':
      r_cmd();
      break;
    case 's':
      s_cmd();
      break;
    case 'v':
      v_cmd();
      break;
    default:
D 11
      printf("Unknown command '%s'.  Type ? for help.\n", arg[0]);
E 11
I 11
      unknown_command();
E 11
      break;
E 44
I 44
    case '\0':                    break;
    case '?':  h_cmd();           break;
    case '[':  host_cmd();        break;
    case 'a':                     break;
    case 'b':  b_cmd();           break;
    case 'c':  c_cmd();           break;
    case 'f':  f_cmd();           break;
    case 'h':  h_cmd();           break;
    case 'i':  i_cmd();           break;
    case 'k':  k_cmd();           break;
    case 'l':  l_cmd();           break;
    case 'q':  b_cmd();           break;
    case 'r':  r_cmd();           break;
    case 's':  s_cmd();           break;
    case 'v':  v_cmd();           break;
    default:   unknown_command(); break;
E 44
E 4
    }
  }
I 4
}

/*---------------------------------------------------------------------------*/

D 48
static void rmail()
{

  FILE * fp;
  char  *p;
  char  buf[1024];
  char  from[1024];
  char  subject[1024];
I 15
  char  tempfile[80];
E 15
  int  i;
I 25
  int  state = 0;
E 25

  *subject = '\0';
  if (scanf("%*s%s", buf) != 1) halt;
  p = strrchr(buf, '!');
  strcpy(from, p ? p + 1 : buf);
  if (!getstring(buf)) halt;
D 12
  if (!(fp = fopen(tempfile, "w"))) halt;
E 12
I 12
D 15
  fp = create_tempfile();
E 15
I 15
  fp = create_tempfile(tempfile);
E 15
E 12
D 25
  while (getstring(buf)) {
    fputs(buf, fp);
    putc('\n', fp);
D 15
    if (!strncmp(buf, "Subject: ", 9)) strcpy(subject, buf + 9);
E 15
I 15
    if (!*subject && !strncmp(buf, "Subject: ", 9)) strcpy(subject, buf + 9);
E 15
  }
E 25
I 25
  while (getstring(buf))
    switch (state) {
    case 0:
      if (!*subject && !strncmp(buf, "Subject: ", 9)) strcpy(subject, buf + 9);
      if (*buf) continue;
      state = 1;
    case 1:
      if (!*buf) continue;
      state = 2;
    case 2:
      fputs(buf, fp);
      putc('\n', fp);
    }
E 25
  fclose(fp);
D 15
  store("", 'B', subject, '$', "ALLE", "ALLE", from);
E 15
I 15
D 16
  store(tempfile, "", 'B', subject, '$', "ALLE", "ALLE", from);
E 16
I 16
  store_in_bbs(tempfile, "", 'B', subject, '$', "ALLE", "ALLE", from);
E 16
E 15
  switch (fork()) {
  case -1:
    halt;
  case 0:
    setpgrp();
    signal(SIGCLD, SIG_DFL);
I 12
    setuid(0);
    setgid(1);
E 12
    for (i = 0; i < _NFILE; i++) close(i);
    fopen(tempfile, "r");
    fopen("/dev/null", "r+");
    fopen("/dev/null", "r+");
    unlink(tempfile);
D 15
    execl("/usr/contrib/bin/inotes", "/usr/contrib/bin/inotes", "-n", debug ? "junk" : "dnet.ham", "-t", subject, 0);
E 15
I 15
    execl("/usr/contrib/bin/inotes", "/usr/contrib/bin/inotes", "-n", debug ? "dk5sg.test" : "dnet.ham", "-t", subject, 0);
E 15
    exit(1);
  }
}

/*---------------------------------------------------------------------------*/

static void rnews()
{

  FILE * fp;
I 15
  char  *p;
E 15
  char  buf[1024];
  char  from[1024];
  char  subject[1024];
I 15
  char  tempfile[80];
E 15
  int  n;
  int  valid;

  while (fgets(buf, sizeof(buf), stdin)) {
    if (strncmp(buf, "#! rnews ", 9)) halt;
    n = atoi(buf + 9);
I 15
    *from = '\0';
E 15
    *subject = '\0';
    valid = 1;
D 12
    if (!(fp = fopen(tempfile, "w"))) halt;
E 12
I 12
D 15
    fp = create_tempfile();
E 15
I 15
    fp = create_tempfile(tempfile);
E 15
E 12
    while (n > 0) {
      if (!fgets(buf, n < sizeof(buf) ? n + 1 : (int) sizeof(buf), stdin)) halt;
      n -= strlen(buf);
      strtrim(buf);
      fputs(buf, fp);
      putc('\n', fp);
D 13
      if (!strncmp(buf, "Subject: ", 9))
E 13
I 13
D 14
      if (!strncmp(buf, "Subject: ", 9)) {
E 13
	strcpy(subject, buf + 9);
D 13
      else if (!strncmp(buf, "Path: ", 6))
	strcpy(from, strrchr(buf + 6, '!') + 1);
      else if (!strcmp(buf, "Organization: dk5sg"))
	valid = 0;
E 13
I 13
      } else if (!strncmp(buf, "Path: ", 6)) {
E 14
I 14
D 15
      if (!strncmp(buf, "Subject: ", 9)) strcpy(subject, buf + 9);
      if (!strncmp(buf, "Path: ", 6)) {
E 14
	strcpy(from, strrchr(buf, '!') + 1);
D 14
	if (!strpos(buf, utsname.nodename)) valid = 0;
E 14
I 14
	if (strpos(buf, utsname.nodename)) valid = 0;
E 15
I 15
      if (!*from && !strncmp(buf, "From: ", 6)) {
	strcpy(from, buf + 6);
	if (p = strchr(from, '@')) *p = '\0';
	if (p = strchr(from, '%')) *p = '\0';
	if (!strcmp(from, "notes")) valid = 0;
E 15
E 14
      }
I 15
      if (!*subject && !strncmp(buf, "Subject: ", 9)) strcpy(subject, buf + 9);
E 15
E 13
    }
    fclose(fp);
D 10
    if (valid) store("", 'B', subject, '$', "ALLE", "ALLE", from);
E 10
I 10
D 15
    if (valid && !host_in_header(tempfile, utsname.nodename)) store("", 'B', subject, '$', "ALLE", "ALLE", from);
E 15
I 15
D 16
    if (valid && !host_in_header(tempfile, utsname.nodename)) store(tempfile, "", 'B', subject, '$', "ALLE", "ALLE", from);
E 16
I 16
D 21
    if (valid && !host_in_header(tempfile, utsname.nodename)) store_in_bbs(tempfile, "", 'B', subject, '$', "ALLE", "ALLE", from);
E 21
I 21
    if (valid && !host_in_header(tempfile, utsname.nodename))
      store_in_bbs(tempfile, "", 'B', subject, '$', "ALLE", "ALLE", from);
E 21
E 16
E 15
E 10
    if (unlink(tempfile)) halt;
  }
}

/*---------------------------------------------------------------------------*/

E 48
D 51
int  main(argc, argv)
E 51
I 51
main(argc, argv)
E 51
int  argc;
char  **argv;
{

#define BBS   0
#define RMAIL 1
#define RNEWS 2

I 38
  char  *cp;
E 38
  char  *dir = WRKDIR;
  int  c;
  int  err_flag = 0;
  int  mode = BBS;

  superuser = (getuid() == 0 && getgid() == 1);
D 12
  setuid(0);
  setgid(1);
E 12
  umask(022);
D 48
  signal(SIGCLD, SIG_IGN);
E 48
D 51
  if (uname(&utsname)) halt;
E 51
I 51
  if (uname(&utsname)) halt();
  myhostname = utsname.nodename;
  mydesc = MYDESC;
E 51
D 7
  loginname = getenv("LOGNAME");
E 7
I 7
D 8
  loginname = getenv("CALL");
  if (!loginname || !*loginname) loginname = getenv("LOGNAME");
E 8
I 8
D 38
  loginname = getenv("LOGNAME");
E 8
E 7
  if (!loginname || !*loginname) halt;
I 21
  if (!strcmp(loginname, "dg3saj")) loginname = "db0cz";
I 37
  if (!strcmp(loginname, "dl5uy")) loginname = "db0ie";
E 38
I 38
  cp = getenv("LOGNAME");
D 51
  if (!cp || !*cp) halt;
  fix_call(cp, loginname);
E 51
I 51
  if (!cp || !*cp) halt();
  strlwc(strcpy(loginname, cp));
E 51
E 38
E 37
E 21
  while ((c = getopt(argc, argv, "dmn")) != EOF)
    switch (c) {
    case 'd':
      debug = 1;
      dir = DEBUGDIR;
      break;
    case 'm':
      mode = RMAIL;
      break;
    case 'n':
      mode = RNEWS;
      break;
    case '?':
      err_flag = 1;
      break;
    }
  if (optind < argc) err_flag = 1;
  if (err_flag) {
    puts("usage: bbs [-d] [-m|-n]");
    exit(1);
  }
  mkdir(dir, 0755);
D 51
  if (chdir(dir)) halt;
  if ((findex = open("index", O_RDWR | O_CREAT, 0644)) < 0) halt;
E 51
I 51
  if (chdir(dir)) halt();
  if ((findex = open("index", O_RDWR | O_CREAT, 0644)) < 0) halt();
E 51
  mkdir("seq", 0755);
D 48
  mkdir("tmp", 0755);
E 48
D 12
  sprintf(tempfile, "tmp/tmp.%d", getpid());
E 12
I 6
  get_seq();
E 6
  switch (mode) {
  case BBS:
    bbs();
    break;
  case RMAIL:
    rmail();
    break;
  case RNEWS:
    rnews();
    break;
  }
  exit(0);
  return 0;
E 4
}
I 38

E 38
E 1
